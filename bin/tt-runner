#!/usr/bin/env python2

'''
TT-Runner: A Test Scripts Runner
'''

from argparse import ArgumentParser
from copy import copy
import os
import random
import re
import shutil
from signal import SIGINT
from subprocess import Popen, PIPE, STDOUT
import sys
import time

# global configuration object
world = None

# default configuration values
default = {
        'output dir'   : '/tmp/tt-runner',
        'test regex'   : 'test',
        'run regex'    : 'run',
        'before regex' : 'before',
        'after regex'  : 'after',
        'init regex'   : 'init',
        'final regex'  : 'final',
        }

class MyParser(ArgumentParser):
    '''
    My argument parser
    '''

    def __new__(cls):
        '''
        Create my parser. Define options and usage document.
        '''
        parser = ArgumentParser(description='A Test Scripts Runner')

        parser.add_argument(
                'PATH',
                nargs=1,
                help='path to the root directory of a test suite')
        d = default['output dir']
        parser.add_argument(
                '-o', '--output',
                metavar='PATH',
                nargs=1,
                # do not set default value because we change behavior
                # if this option is set or not in Environment()
                default=[d],
                help=('path to a directory saving the result. '
                      'default: {0}').format(d))
        parser.add_argument(
                '--color',
                action='store_true',
                help='color output')
        parser.add_argument(
                '--no-change-dir',
                action='store_true',
                help='do not change the working directory')


        quality_group = parser.add_argument_group(
                'options for improvement of test suites')
        quality_group.add_argument(
                '--randomize',
                metavar='SEED',
                nargs='?',
                type=int,
                default=None, # it means this options is not set
                const=random.randint(0,65535),
                help='randomize the order of running tests')
        quality_group.add_argument(
                '--multiply-preconditioning',
                action='store_true',
                help='run preconditioning scripts twice in a row')


        debug_group = parser.add_argument_group(
                'options for testing of test suites')
        debug_group.add_argument(
                '--print-log',
                action='store_true',
                help='print stdout and stderr of running scripts')
        debug_group.add_argument(
                '--stop-on-failure',
                action='store_true',
                help='skip remaining operations if an operation fails')

        skip_group = debug_group.add_mutually_exclusive_group()
        skip_group.add_argument(
                '--skip-all',
                action='store_true',
                help='skip all operations')
        skip_group.add_argument(
                '--only',
                metavar='N',
                nargs='+',
                type=int,
                default=[],
                help='run only specified operations')
        skip_group.add_argument(
                '--skip',
                metavar='N',
                nargs='+',
                type=int,
                default=[],
                help='skip specified operations')


        prefix_group = parser.add_argument_group(
                'regular expressions for classifying node types')
        d = default['test regex']
        prefix_group.add_argument(
                '--test-regex',
                metavar='RE',
                nargs=1,
                default=[d],
                help=('regex matching with test nodes. '
                      'default: {0}').format(d))
        d = default['run regex']
        prefix_group.add_argument(
                '--run-regex',
                metavar='RE',
                nargs=1,
                default=[d],
                help=('regex matching with run nodes. '
                      'default: {0}').format(d))
        d = default['before regex']
        prefix_group.add_argument(
                '--before-regex',
                metavar='RE',
                nargs=1,
                default=[d],
                help=('regex matching with before nodes. '
                      'default: {0}').format(d))
        d = default['after regex']
        prefix_group.add_argument(
                '--after-regex',
                metavar='RE',
                nargs=1,
                default=[d],
                help=('regex matching with after nodes. '
                      'default: {0}').format(d))
        d = default['init regex']
        prefix_group.add_argument(
                '--init-regex',
                metavar='RE',
                nargs=1,
                default=[d],
                help=('regex matching with init nodes. '
                      'default: {0}').format(d))
        d = default['final regex']
        prefix_group.add_argument(
                '--final-regex',
                metavar='RE',
                nargs=1,
                default=[d],
                help=('regex matching with final nodes. '
                      'default: {0}').format(d))

        return parser

class Environment(dict):
    '''
    Dictionally of configuration properties
    '''

    def __init__(self):
        args = MyParser().parse_args()

        self['root dir'] = os.path.abspath(args.PATH[0])
        self['output dir'] = os.path.abspath(args.output[0])
        self['color output'] = args.color
        self['change dir'] = not args.no_change_dir

        ## Quality options

        # when --randomize option is assigned
        if args.randomize:
            self['randomize'] = True
            self['random seed'] = args.randomize
            random.seed(args.randomize)
        else:
            self['randomize'] = False

        self['multiply preconditioning'] = args.multiply_preconditioning

        ## Testing for test options

        self['print log'] = args.print_log
        self['stop on failure'] = args.stop_on_failure

        # note: can be changed in running
        self['skip all']  = args.skip_all

        self['only list'] = args.only
        self['skip list'] = args.skip

        ## Regex options

        self['test regex'] = re.compile(args.test_regex[0])
        self['run regex'] = re.compile(args.run_regex[0])
        self['before regex'] = re.compile(args.before_regex[0])
        self['after regex'] = re.compile(args.after_regex[0])
        self['init regex'] = re.compile(args.init_regex[0])
        self['final regex'] = re.compile(args.final_regex[0])

    def setup(self):
        '''
        Set up environment.
        '''
        # for repeatable running, cleanup the output directory
        # if -o option is not assigned
        d = default['output dir']
        if self['output dir'] == d:
            if os.path.lexists(d):
                shutil.rmtree(d)

        # create the output directory
        os.makedirs(self['output dir'])

        # set environment variables in the process
        os.environ['TT_RUNNER_EXEC_DIR'] = os.getcwd()
        os.environ['TT_RUNNER_ROOT_DIR'] = self['root dir']
        os.environ['TT_RUNNER_OUTPUT_DIR'] = self['output dir']

class Node():
    '''
    A node of the scripts tree, a directory.
    '''

    def __init__(self, path,
            tests, runs,
            befores, afters,
            inits, finals):

        # absolute path to the file directory
        self.path = os.path.abspath(path)

        # child nodes
        self.tests = tests
        self.runs = runs
        self.befores = befores
        self.afters = afters
        self.inits = inits
        self.finals = finals

    def __str__(self):
        return os.path.relpath(self.path, world["root dir"])

    def name(self):
        '''
        Get the directory or file name, not the path.
        '''
        return os.path.basename(self.path)

    def is_empty(self):
        if (self.tests and self.runs and
            self.befores and self.afters and
            self.inits and self.finals):
            return True
        else:
            return False

    def accept(self, visitor):
        visitor.visit_node(self)

class Leaf(Node):
    '''
    A script file
    '''

    def __init__(self, path):
        # absolute path to the file
        self.path = os.path.abspath(path)

    def is_empty(self):
        return False

    def accept(self, visitor):
        visitor.visit_leaf(self)

class NodeGroup(list):
    '''
    List of node objects
    '''

    def randomized(self):
        '''
        Return randomized node list
        '''
        out = self.sorted()
        if world['randomize']:
            random.shuffle(out)
        return out

    def sorted(self, reverse=False):
        '''
        Return node list sorted by path name
        '''
        return sorted(self, key=lambda node: node.path, reverse=reverse)

class TestGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_test_group(self)

class RunGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_run_group(self)

class BeforeGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_before_group(self)

class AfterGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_after_group(self)

class InitGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_init_group(self)

class FinalGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_final_group(self)

class Tree():
    '''
    A tree of node objects.
    It traces the directory structure of test scripts
    '''

    def __init__(self, root_path):
        '''
        Create tree
        '''
        self.root_node = self.__create_nodes(root_path)

    class StringFormatter():
        def get_string(self, tree):
            self.string = ''
            self.indent = ''
            tree.root_node.accept(self)
            return self.string

        def visit_node(self, node):
            self.string += self.indent + '- ' + node.name() + '\n'

            indent_copy = copy(self.indent)
            self.indent += '  '

            node.inits.accept(self)
            node.befores.accept(self)
            node.runs.accept(self)
            node.tests.accept(self)
            node.afters.accept(self)
            node.finals.accept(self)

            self.indent = indent_copy

        def visit_leaf(self, leaf):
            self.string += self.indent + '- ' + leaf.name() + '\n'

        def visit_test_group(self, test_group):
            for test in test_group.sorted():
                test.accept(self)

        def visit_run_group(self, run_group):
            for run in run_group.sorted():
                run.accept(self)

        def visit_before_group(self, before_group):
            for before in before_group.sorted():
                before.accept(self)

        def visit_after_group(self, after_group):
            for after in after_group.sorted(reverse=True):
                after.accept(self)

        def visit_init_group(self, init_group):
            for init in init_group.sorted():
                init.accept(self)

        def visit_final_group(self, final_group):
            for final in final_group.sorted(reverse=True):
                final.accept(self)

    def __str__(self):
        return Tree.StringFormatter().get_string(self)

    def __create_nodes(self, path):
        '''
        Create node objects under the path recursively.
        return a node object that represents the path
        '''

        if os.path.isfile(path):
            return Leaf(path)

        def __create_child_nodes(childs, regex):
            names = filter(lambda n : regex.match(n), childs)
            pathes = map(lambda n : os.path.join(path, n), names)
            nodes = map(lambda p : self.__create_nodes(p), pathes)
            non_empty_nodes = filter(lambda n : not n.is_empty(), nodes)
            return non_empty_nodes

        childs = os.listdir(path)

        tests = TestGroup()
        nodes = __create_child_nodes(childs, world['test regex'])
        tests.extend(nodes)

        runs = RunGroup()
        nodes = __create_child_nodes(childs, world['run regex'])
        runs.extend(nodes)

        befores = BeforeGroup()
        nodes = __create_child_nodes(childs, world['before regex'])
        befores.extend(nodes)

        afters = AfterGroup()
        nodes = __create_child_nodes(childs, world['after regex'])
        afters.extend(nodes)

        inits = InitGroup()
        nodes = __create_child_nodes(childs, world['init regex'])
        inits.extend(nodes)

        finals = FinalGroup()
        nodes = __create_child_nodes(childs, world['final regex'])
        finals.extend(nodes)

        return Node(path, tests, runs,
                    befores, afters, inits, finals)

class Console():
    __color_head = {
        'red'    : '\033[91m',
        'green'  : '\033[92m',
        'yellow' : '\033[93m',
        'blue'   : '\033[94m',
    }

    def __init__(self, out):
        self.out = out

    def write(self, message, color=None):
        end = '\033[0m'
        if world['color output'] and color:
            message = Console.__color_head[color] + message + end
        self.out.write(message)
        self.out.flush()

class NullFile():
    def write(self, string):
        pass
    def flush(self):
        pass

class Executor():
    '''
    A runner for simple executable files
    '''

    def run(self, operation):

        # Skip if the file is not executable.
        if not os.access(operation.path, os.R_OK | os.X_OK):
            operation.status = OpState.SKIPPED
            operation.message = '{0} is not executable.'.format(
                    operation.relpath())
            return

        if world['print log']:
            console = Console(sys.stderr)
        else:
            console = Console(NullFile())

        console.write(
                '\n** run {0:s} **\n'.format(operation.relpath()),
                'blue')

        if world['change dir']:
            # Change the working directory to the directory where
            # the script exists.
            os.chdir(os.path.dirname(operation.path))

        start = time.time()

        process = None
        try:
            process = Popen([operation.path],
                    stdout=PIPE,
                    stderr=STDOUT)
            logfile = os.path.join(
                    world['output dir'], operation.logfile_name())

            # write stdout and stderr of the operation
            # to stderr and logfile
            with process.stdout, open(logfile, 'wb') as f:
                for line in iter(process.stdout.readline, b''):
                    f.write(line)
                    console.write(line)

            process.wait()

        except OSError as e:
            # For the case when the script at the path has not shebang.
            operation.status = OpState.FAILED
            operation.message = ('OSError: ' + str(e) + '\n' +
                            'Is the shebang correct?')
            return

        except KeyboardInterrupt as i:
            process.send_signal(SIGINT)
            process.wait()
            operation.message = 'KeyboardInterrupt'

        end = time.time()
        operation.elapsed = end - start

        if process.returncode != 0:
            operation.status = OpState.FAILED
        else:
            operation.status = OpState.SUCCEEDED

class OpState():
    '''
    Operation state
    '''
    (
        NOT_DONE,
        SUCCEEDED,
        FAILED,
        SKIPPED,
    ) = range(4)

    @staticmethod
    def color(status):
        if status == OpState.SUCCEEDED:
            return 'green'
        if status == OpState.FAILED:
            return 'red'
        if status == OpState.SKIPPED:
            return 'yellow'
        assert False

class Operation():
    '''
    A unit of testing. Represent each executable script file.
    '''

    def __init__(self, path, depends):
        self.path = path
        self.depends = copy(depends)

        self.status = OpState.NOT_DONE
        self.elapsed = 0.0
        self.message = ''
        self.id_num = 0

        self.executor = Executor()

    def set_id(self, id_num):
        assert self.id_num == 0
        assert id_num > 0
        self.id_num = id_num

    def relpath(self):
        return os.path.relpath(self.path, world['root dir'])

    def __str__(self):
        return '{0:d} {1:s}'.format(self.id_num, self.relpath())

    def tap_message(self):
        '''
        Return TAP formatted message
        '''
        if self.message != '':
            # put '# ' at the front of each line
            message = '\n' + '\n'.join(
                  ['# ' + line for line in self.message.splitlines()])
        else:
            message = ''

        if self.status == OpState.SUCCEEDED:
            return 'ok {0:s}{1:s}'.format(self, message)
        elif self.status == OpState.FAILED:
            return 'not ok {0:s}{1:s}'.format(self, message)
        elif self.status == OpState.SKIPPED:
            return 'ok {0:s} # SKIP{1:s}'.format(self, message)
        else:
            assert False

    def logfile_name(self):
        assert self.id_num > 0
        return '{0:d}.{1:s}.out'.format(
                    self.id_num,
                    self.relpath().replace(os.sep, '.'))

    def run(self):
        '''
        Exec this operation.
        The result is set into field variables.
        '''
        assert self.id_num > 0
        assert self.status == OpState.NOT_DONE

        if world['skip all']:
            self.status = OpState.SKIPPED
            return

        if self.id_num in world['skip list']:
            self.status = OpState.SKIPPED
            return

        if (len(world['only list']) > 0 and
                self.id_num not in world['only list']):
            self.status = OpState.SKIPPED
            return

        # Skip if depending operation did not succeed.
        for depend_op in self.depends:
            assert depend_op.status != OpState.NOT_DONE
            if depend_op.status != OpState.SUCCEEDED:
                self.status = OpState.SKIPPED
                self.message = str(depend_op) + ' did not succeed.'
                return

        self.executor.run(self)

class Planner():
    '''
    Create an operation plan
    '''

    # use the visitor design patten.
    # this visits Node class and NodeGroup class recursively.

    def create_plan(self, tree):
        '''
        Return a plan object
        '''
        self.planned_operations = Plan()
        self.depended_operations = []
        tree.root_node.accept(self)
        assert len(self.depended_operations) == 0

        id_num = 0
        for op in self.planned_operations:
            id_num += 1
            op.set_id(id_num)

        return self.planned_operations

    def visit_node(self, node):
        '''
        Define the relations between node types
        '''

        # accept method must be sandwiched between __set and __reset.
        # FIXME: this syntax might be difficult to under stand.
        #        rewrite more readable way.
        __m = []
        def __set(list):
            '''Remember the current state '''
            __m.append(len(list))

        def __reset(list):
            ''' Reset to the remembered state '''
            length = __m.pop()
            del list[length:]

        __set(self.depended_operations)

        node.inits.accept(self)
        if world['multiply preconditioning']:
            node.inits.accept(self)

        # note: temporary execute before-operations and after-operations
        # respectively before and after run-operations. In the future, we
        # might prohibit that a node contains both of run-operations and
        # other operations.

        if len(node.runs) > 0:
            __set(self.depended_operations)

            node.befores.accept(self)
            node.runs.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        first_test = True
        for test in node.tests.randomized():
            __set(self.depended_operations)

            node.befores.accept(self)
            if world['multiply preconditioning'] and first_test:
                node.befores.accept(self)
            first_test = False

            test.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        __reset(self.depended_operations)
        __set(self.depended_operations)

        node.finals.accept(self)

        __reset(self.depended_operations)

    def visit_leaf(self, leaf):
        '''
        Add new operation object
        '''
        operation = Operation(leaf.path, self.depended_operations)
        self.planned_operations.append(operation)
        self.depended_operations.append(operation)

    def visit_test_group(self, test_group):
        '''
        This planner do not do not visit test group
        '''
        assert False

    def visit_run_group(self, run_group):
        '''
        Visit run nodes in the sequential order
        '''
        for run_node in run_group.sorted():
            run_node.accept(self)

    def visit_before_group(self, before_group):
        '''
        Visit bofore nodes in the sequential order
        '''
        for before_node in before_group.sorted():
            before_node.accept(self)

    def visit_after_group(self, after_group):
        '''
        Visit bofore nodes in the reversed order
        '''
        for after_node in after_group.sorted(reverse=True):
            after_node.accept(self)

    def visit_init_group(self, init_group):
        '''
        Visit init nodes in the sequential order
        '''
        for init_node in init_group.sorted():
            init_node.accept(self)

    def visit_final_group(self, final_group):
        '''
        Visit final nodes in the sequential order
        '''
        for final_node in final_group.sorted(reverse=True):
            final_node.accept(self)

class Plan(list):
    '''
    List of operation objects.
    '''

    def run(self):
        '''
        Run the operations
        '''

        console = Console(sys.stdout)
        tapfile = os.path.join(world['output dir'], 'result.txt')
        with open(tapfile, 'w') as f:

            line = self.tap_header() + '\n'
            console.write(line, 'green')
            f.write(line)

            # For each operations
            for op in self:
                op.run()

                # print result
                msg = op.tap_message() + '\n'
                console.write(msg, OpState.color(op.status))
                f.write(msg)

                if world['stop on failure'] and op.status == OpState.FAILED:
                    world['skip all'] = True

    def num_operations(self):
        return len(self)

    def tap_header(self):
        return '1..{0:d}'.format(self.num_operations())

    def succeeded_oparations(self):
        return filter(lambda o : o.status == OpState.SUCCEEDED, self)

    def failed_oparations(self):
        return filter(lambda o : o.status == OpState.FAILED, self)

    def skipped_operations(self):
        return filter(lambda o : o.status  == OpState.SKIPPED, self)

    def total_elapsed_time(self):
        return sum([ o.elapsed for o in self ])

    def has_succeeded(self):
        return not len(self.failed_oparations()) > 0

    def summarize(self):
        '''
        Print the summary of operations.
        Return False if one or more operations are failed.
        '''

        console = Console(sys.stderr)

        table = (
            '---\n'
            'operations       : {0:d}\n'
            'succeeded        : {1:d}\n'
            'failed           : {2:d}\n'
            'skipped          : {3:d}\n'
            'time taken [sec] : {4:.0f}\n'
            ).format(self.num_operations(),
                    len(self.succeeded_oparations()),
                    len(self.failed_oparations()),
                    len(self.skipped_operations()),
                    self.total_elapsed_time())

        if world['randomize']:
            table += ('random seed      : {0:d}\n'
                .format(world['random seed']))

        console.write(table)

        if self.has_succeeded():
            console.write('\nSUCCESS\n\n', 'green')
        else:
            console.write('\nFAILURE\n\n', 'red')

            # list of failed oparations
            lines = [ '- {0:s}\n'.format(o)
                        for o in self.failed_oparations() ]
            console.write(''.join(lines)+ '\n')

if __name__ == '__main__':
    world = Environment()
    world.setup()
    tree = Tree(world['root dir'])
    plan = Planner().create_plan(tree)
    plan.run()
    plan.summarize()

    if not plan.has_succeeded():
        sys.exit(1)
    else:
        sys.exit(0)
