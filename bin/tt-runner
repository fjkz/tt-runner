#!/usr/bin/env python2
# coding: utf-8

'''
TT-Runner: A Test Scripts Runner
'''

from argparse import ArgumentParser
from copy import copy
import os
import random
import re
import shutil
from signal import SIGINT
from subprocess import Popen, PIPE, STDOUT
import sys
import time

# global configuration object
world = None

# default configuration values
default = {
    'output dir': '/tmp/tt-runner',
    'test regex': 'test',
    'run regex': 'run',
    'before regex': 'before',
    'after regex': 'after',
    'init regex': 'init',
    'final regex': 'final',
    }


class MyParser(ArgumentParser):
    '''
    My argument parser
    '''

    def __new__(cls):
        '''
        Create my parser. Define options and usage document.
        '''
        parser = ArgumentParser(description='A Test Scripts Runner')

        parser.add_argument(
            'PATH',
            nargs=1,
            help='path to the root directory of a test suite')
        d = default['output dir']
        parser.add_argument(
            '-o', '--output',
            metavar='PATH',
            nargs=1,
            # do not set default value because we change behavior
            # if this option is set or not in Environment()
            default=[d],
            help=('path to a directory saving the result. '
                  'default: {0}').format(d))

        parser.add_argument(
            '--tap',
            action='store_true',
            default=False,
            help='show result in TAP format')

        parser.add_argument(
            '--no-color',
            action='store_true',
            help='do not color output')

        parser.add_argument(
            '--no-change-dir',
            action='store_true',
            help='do not change the working directory')

        quality_group = parser.add_argument_group(
            'options for improvement of test suites')
        quality_group.add_argument(
            '--randomize',
            metavar='SEED',
            nargs='?',
            type=int,
            default=None,  # it means this options is not set
            const=random.randint(0, 65535),
            help='randomize the order of running tests')
        quality_group.add_argument(
            '--multiply-preconditioning',
            action='store_true',
            help='run preconditioning scripts twice in a row')

        debug_group = parser.add_argument_group(
            'options for testing of test suites')
        debug_group.add_argument(
            '--print-log',
            action='store_true',
            help='print stdout and stderr of running scripts')
        debug_group.add_argument(
            '--stop-on-failure',
            action='store_true',
            help='skip remaining operations if an operation fails')

        skip_group = debug_group.add_mutually_exclusive_group()
        skip_group.add_argument(
            '--skip-all',
            action='store_true',
            help='skip all operations')
        skip_group.add_argument(
            '--only',
            metavar='NAME',
            nargs='+',
            type=str,
            default=[],
            help='run only specified scripts')
        skip_group.add_argument(
            '--skip',
            metavar='NAME',
            nargs='+',
            type=str,
            default=[],
            help='skip specified scripts')

        prefix_group = parser.add_argument_group(
            'regular expressions for classifying node types')
        d = default['test regex']
        prefix_group.add_argument(
            '--test-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with test nodes. '
                  'default: {0}').format(d))
        d = default['run regex']
        prefix_group.add_argument(
            '--run-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with run nodes. '
                  'default: {0}').format(d))
        d = default['before regex']
        prefix_group.add_argument(
            '--before-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with before nodes. '
                  'default: {0}').format(d))
        d = default['after regex']
        prefix_group.add_argument(
            '--after-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with after nodes. '
                  'default: {0}').format(d))
        d = default['init regex']
        prefix_group.add_argument(
            '--init-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with init nodes. '
                  'default: {0}').format(d))
        d = default['final regex']
        prefix_group.add_argument(
            '--final-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with final nodes. '
                  'default: {0}').format(d))

        return parser


class Environment(dict):
    '''
    Dictionally of configuration properties
    '''

    def __init__(self):
        args = MyParser().parse_args()

        self['root dir'] = os.path.abspath(args.PATH[0])
        self['output dir'] = os.path.abspath(args.output[0])

        if args.tap is True:
            self['format'] = 'TAP'
        else:
            self['format'] = 'pretty'

        self['color output'] = not args.no_color
        self['change dir'] = not args.no_change_dir

        ## Quality options

        # when --randomize option is assigned
        if args.randomize:
            self['randomize'] = True
            self['random seed'] = args.randomize
            random.seed(args.randomize)
        else:
            self['randomize'] = False

        self['multiply preconditioning'] = args.multiply_preconditioning

        ## Testing for test options

        self['print log'] = args.print_log
        self['stop on failure'] = args.stop_on_failure

        # note: can be changed in running
        self['skip all'] = args.skip_all

        # absolute paths of only-run files or directory
        self['only list'] = [os.path.join(self['root dir'], n)
                             for n in args.only]
        # absolute paths of skipped files
        self['skip list'] = [os.path.join(self['root dir'], n)
                             for n in args.skip]

        for p in self['skip list'] + self['only list']:
            assert os.path.exists(p), p + ' does not exists'

        ## Regex options

        self['test regex'] = re.compile(args.test_regex[0])
        self['run regex'] = re.compile(args.run_regex[0])
        self['before regex'] = re.compile(args.before_regex[0])
        self['after regex'] = re.compile(args.after_regex[0])
        self['init regex'] = re.compile(args.init_regex[0])
        self['final regex'] = re.compile(args.final_regex[0])

    def setup(self):
        '''
        Set up environment.
        '''
        # for repeatable running, cleanup the output directory
        # if -o option is not assigned
        d = default['output dir']
        if self['output dir'] == d:
            if os.path.lexists(d):
                shutil.rmtree(d)

        # create the output directory
        os.makedirs(self['output dir'])

        # set environment variables in the process
        os.environ['TT_RUNNER_EXEC_DIR'] = os.getcwd()
        os.environ['TT_RUNNER_ROOT_DIR'] = self['root dir']
        os.environ['TT_RUNNER_OUTPUT_DIR'] = self['output dir']


class Node():
    '''
    A node of the scripts tree, a directory.
    '''

    def __init__(
            self, path,
            tests, runs,
            befores, afters,
            inits, finals):

        # absolute path to the file directory
        self.path = os.path.abspath(path)

        # child nodes
        self.tests = tests
        self.runs = runs
        self.befores = befores
        self.afters = afters
        self.inits = inits
        self.finals = finals

    def __str__(self):
        return os.path.relpath(self.path, world["root dir"])

    def name(self):
        '''
        Get the directory or file name, not the path.
        '''
        return os.path.basename(self.path)

    def is_empty(self):
        if (self.tests and self.runs and
                self.befores and self.afters and
                self.inits and self.finals):
            return True
        else:
            return False

    def accept(self, visitor):
        visitor.visit_node(self)


class Leaf(Node):
    '''
    A script file
    '''

    def __init__(self, path):
        # absolute path to the file
        self.path = os.path.abspath(path)

    def is_empty(self):
        return False

    def accept(self, visitor):
        visitor.visit_leaf(self)


class NodeGroup(list):
    '''
    List of node objects
    '''

    def randomized(self):
        '''
        Return randomized node list
        '''
        out = self.sorted()
        if world['randomize']:
            random.shuffle(out)
        return out

    def sorted(self, reverse=False):
        '''
        Return node list sorted by path name
        '''
        return sorted(self, key=lambda node: node.path, reverse=reverse)


class TestGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_test_group(self)


class RunGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_run_group(self)


class BeforeGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_before_group(self)


class AfterGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_after_group(self)


class InitGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_init_group(self)


class FinalGroup(NodeGroup):
    def accept(self, visitor):
        visitor.visit_final_group(self)


class Tree():
    '''
    A tree of node objects.
    It traces the directory structure of test scripts
    '''

    def __init__(self, root_path):
        '''
        Create tree
        '''
        self.root_node = self.__create_nodes(root_path)

    class StringFormatter():
        def get_string(self, tree):
            self.string = ''
            self.indent = ''
            tree.root_node.accept(self)
            return self.string

        def visit_node(self, node):
            self.string += self.indent + '- ' + node.name() + '\n'

            indent_copy = copy(self.indent)
            self.indent += '  '

            node.inits.accept(self)
            node.befores.accept(self)
            node.runs.accept(self)
            node.tests.accept(self)
            node.afters.accept(self)
            node.finals.accept(self)

            self.indent = indent_copy

        def visit_leaf(self, leaf):
            self.string += self.indent + '- ' + leaf.name() + '\n'

        def visit_test_group(self, test_group):
            for test in test_group.sorted():
                test.accept(self)

        def visit_run_group(self, run_group):
            for run in run_group.sorted():
                run.accept(self)

        def visit_before_group(self, before_group):
            for before in before_group.sorted():
                before.accept(self)

        def visit_after_group(self, after_group):
            for after in after_group.sorted(reverse=True):
                after.accept(self)

        def visit_init_group(self, init_group):
            for init in init_group.sorted():
                init.accept(self)

        def visit_final_group(self, final_group):
            for final in final_group.sorted(reverse=True):
                final.accept(self)

    def __str__(self):
        return Tree.StringFormatter().get_string(self)

    def __create_nodes(self, path):
        '''
        Create node objects under the path recursively.
        return a node object that represents the path
        '''

        if os.path.isfile(path):
            return Leaf(path)

        def __create_child_nodes(childs, regex):
            names = filter(lambda n: regex.match(n), childs)
            pathes = map(lambda n: os.path.join(path, n), names)
            nodes = map(lambda p: self.__create_nodes(p), pathes)
            non_empty_nodes = filter(lambda n: not n.is_empty(), nodes)
            return non_empty_nodes

        childs = os.listdir(path)

        tests = TestGroup()
        nodes = __create_child_nodes(childs, world['test regex'])
        tests.extend(nodes)

        runs = RunGroup()
        nodes = __create_child_nodes(childs, world['run regex'])
        runs.extend(nodes)

        befores = BeforeGroup()
        nodes = __create_child_nodes(childs, world['before regex'])
        befores.extend(nodes)

        afters = AfterGroup()
        nodes = __create_child_nodes(childs, world['after regex'])
        afters.extend(nodes)

        inits = InitGroup()
        nodes = __create_child_nodes(childs, world['init regex'])
        inits.extend(nodes)

        finals = FinalGroup()
        nodes = __create_child_nodes(childs, world['final regex'])
        finals.extend(nodes)

        return Node(path, tests, runs,
                    befores, afters, inits, finals)


class Printer():
    __color_head = {
        'red': '\033[91m',
        'green': '\033[92m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
    }

    def __init__(self, out):
        self.out = out

    def write(self, message, color=None):
        if world['color output'] and color:
            end = '\033[0m'
            message = Printer.__color_head[color] + message + end
        self.out.write(message)
        self.out.flush()


class NullFile():

    def write(self, string):
        pass

    def flush(self):
        pass


class Executor():
    '''
    A runner for simple executable files
    '''

    def run(self, operation):

        # Skip if the file is not executable.
        if not os.access(operation.path, os.R_OK | os.X_OK):
            operation.status = OpState.SKIPPED
            operation.message = '{0} is not executable.'.format(
                operation.relpath())
            return

        if world['print log']:
            console = Printer(sys.stderr)
        else:
            console = Printer(NullFile())

        console.write(
            '\n➤ {0:s}\n'.format(operation),
            'blue')

        if world['change dir']:
            # Change the working directory to the directory where
            # the script exists.
            os.chdir(os.path.dirname(operation.path))

        start = time.time()

        process = None
        try:
            process = Popen(
                [operation.path],
                stdout=PIPE,
                stderr=STDOUT)
            logfile = os.path.join(
                world['output dir'], operation.logfile_name())

            # write stdout and stderr of the operation
            # to stderr and logfile
            with process.stdout, open(logfile, 'wb') as f:
                for line in iter(process.stdout.readline, b''):
                    f.write(line)
                    console.write(line)

            process.wait()

        except OSError as e:
            # For the case when the script at the path has not shebang.
            operation.status = OpState.FAILED
            operation.message = (
                'OSError: ' + str(e) + '\n'
                'Is the shebang correct?')
            return

        except KeyboardInterrupt as i:
            process.send_signal(SIGINT)
            process.wait()
            operation.message = 'KeyboardInterrupt'

        end = time.time()
        operation.elapsed = end - start

        if process.returncode != 0:
            operation.status = OpState.FAILED
        else:
            operation.status = OpState.SUCCEEDED


class OpState():
    '''
    Operation state
    '''
    (
        NOT_DONE,
        SUCCEEDED,
        FAILED,
        SKIPPED,
    ) = range(4)

    @staticmethod
    def color(status):
        if status == OpState.SUCCEEDED:
            return 'green'
        if status == OpState.FAILED:
            return 'red'
        if status == OpState.SKIPPED:
            return 'yellow'
        assert False


class Operation():
    '''
    A unit of testing. Represent each executable script file.
    '''

    def __init__(self, path, depends):
        self.path = path
        self.depends = copy(depends)

        self.status = OpState.NOT_DONE
        self.elapsed = 0.0
        self.message = ''

        # unique number among all operations
        self.id_num = 0

        # unique number among operations with the same file
        # 1 or more value is set if a file associated to
        # two or more operations.
        self.serial_num = 0

        self.executor = Executor()

    def set_id(self, id_num):
        assert self.id_num == 0
        assert id_num > 0
        self.id_num = id_num

    def set_serial(self, serial_num):
        assert self.serial_num == 0
        assert serial_num > 0
        self.serial_num = serial_num

    def relpath(self):
        return os.path.relpath(self.path, world['root dir'])

    def __str__(self):
        if self.serial_num > 0:
            return '{0:s}.{1:d}'.format(
                self.relpath(), self.serial_num)
        else:
            return self.relpath()

    def logfile_name(self):
        return '{0:s}.out'.format(
            str(self).replace(os.sep, '.'))

    def run(self):
        '''
        Exec this operation.
        The result is set into field variables.
        '''
        assert self.id_num > 0
        assert self.status == OpState.NOT_DONE

        if world['skip all']:
            self.status = OpState.SKIPPED
            return

        # skip if the path of the operation is
        # under the directory in skip list
        for skip_file in world['skip list']:
            if self.path.startswith(skip_file):
                self.status = OpState.SKIPPED
                return

        # skip if the path of the operation is
        # under the directory in only list
        if len(world['only list']) > 0:
            for only_file in world['only list']:
                if self.path.startswith(only_file):
                    break
            else:
                self.status = OpState.SKIPPED
                return

        # Skip if depending operation did not succeed.
        for depend_op in self.depends:
            assert depend_op.status != OpState.NOT_DONE
            if depend_op.status != OpState.SUCCEEDED:
                self.status = OpState.SKIPPED
                self.message = (
                    'depending operation did not succeed: ' +
                    str(depend_op))
                return

        self.executor.run(self)


class Planner():
    '''
    Create an operation plan
    '''

    # use the visitor design patten.
    # this visits Node class and NodeGroup class recursively.

    def create_plan(self, tree):
        '''
        Return a plan object
        '''
        self.planned_operations = Plan()
        self.depended_operations = []
        tree.root_node.accept(self)
        assert len(self.depended_operations) == 0

        # set id numbers
        id_num = 0
        for op in self.planned_operations:
            id_num += 1
            op.set_id(id_num)

        # set serial numbers
        for op in self.planned_operations:
            c = filter(
                lambda o: o.path == op.path, self.planned_operations)
            assert len(c) > 0
            if len(c) == 1:
                continue
            n = max(map(lambda o: o.serial_num, c))
            op.set_serial(n + 1)

        return self.planned_operations

    def visit_node(self, node):
        '''
        Define the relations between node types
        '''

        # accept method must be sandwiched between __set and __reset.
        # FIXME: this syntax might be difficult to under stand.
        #        rewrite more readable way.
        __m = []

        def __set(list):
            '''Remember the current state '''
            __m.append(len(list))

        def __reset(list):
            ''' Reset to the remembered state '''
            length = __m.pop()
            del list[length:]

        __set(self.depended_operations)

        node.inits.accept(self)
        if world['multiply preconditioning']:
            node.inits.accept(self)

        # note: temporary execute before-operations and after-operations
        # respectively before and after run-operations. In the future, we
        # might prohibit that a node contains both of run-operations and
        # other operations.

        if len(node.runs) > 0:
            __set(self.depended_operations)

            node.befores.accept(self)
            node.runs.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        first_test = True
        for test in node.tests.randomized():
            __set(self.depended_operations)

            node.befores.accept(self)
            if world['multiply preconditioning'] and first_test:
                node.befores.accept(self)
            first_test = False

            test.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        __reset(self.depended_operations)
        __set(self.depended_operations)

        node.finals.accept(self)

        __reset(self.depended_operations)

    def visit_leaf(self, leaf):
        '''
        Add new operation object
        '''
        operation = Operation(leaf.path, self.depended_operations)
        self.planned_operations.append(operation)
        self.depended_operations.append(operation)

    def visit_test_group(self, test_group):
        '''
        This planner do not do not visit test group
        '''
        assert False

    def visit_run_group(self, run_group):
        '''
        Visit run nodes in the sequential order
        '''
        for run_node in run_group.sorted():
            run_node.accept(self)

    def visit_before_group(self, before_group):
        '''
        Visit bofore nodes in the sequential order
        '''
        for before_node in before_group.sorted():
            before_node.accept(self)

    def visit_after_group(self, after_group):
        '''
        Visit bofore nodes in the reversed order
        '''
        for after_node in after_group.sorted(reverse=True):
            after_node.accept(self)

    def visit_init_group(self, init_group):
        '''
        Visit init nodes in the sequential order
        '''
        for init_node in init_group.sorted():
            init_node.accept(self)

    def visit_final_group(self, final_group):
        '''
        Visit final nodes in the sequential order
        '''
        for final_node in final_group.sorted(reverse=True):
            final_node.accept(self)


class PrettyFormat():
    '''
    Pretty format
    '''

    def __init__(self, printer):
        self.printer = printer

    def header(self, plan):
        '''
        No header
        '''
        pass

    def case(self, op):
        '''
        Print pretty test case results
        '''

        if op.status == OpState.SUCCEEDED:
            s = '✓ {0:s}\n'.format(op)
            self.printer.write(s, 'green')
        elif op.status == OpState.FAILED:
            s = '✗ {0:s}\n'.format(op)
            self.printer.write(s, 'red')
        elif op.status == OpState.SKIPPED:
            s = '− {0:s}\n'.format(op)
            self.printer.write(s, 'yellow')
        else:
            assert False

        if op.message != '':
            message = (
                '\n'.join(
                    ['  ' + line for line in op.message.splitlines()])
                + '\n'
                )
            self.printer.write(message)

    def footer(self, plan):
        '''
        Print summury
        '''

        table = (
            '\n'
            'operations       : {0:d}\n'
            'succeeded        : {1:d}\n'
            'failed           : {2:d}\n'
            ).format(
            plan.num_operations(),
            len(plan.succeeded_oparations()),
            len(plan.failed_oparations()))

        n = len(plan.skipped_operations())
        if n > 0:
            table += (
                'skipped          : {0:d}\n'
                .format(n))

        table += (
            'time taken [sec] : {0:.0f}\n'
            .format(plan.total_elapsed_time()))

        if world['randomize']:
            table += (
                'random seed      : {0:d}\n'
                .format(world['random seed']))

        self.printer.write(table)

        if plan.has_succeeded():
            self.printer.write('\nSUCCESS\n', 'green')
        else:
            self.printer.write('\nFAILURE\n', 'red')

            # list of failed oparations
            lines = [
                '- {0:s}\n'.format(o)
                for o in plan.failed_oparations()]
            self.printer.write('\n' + ''.join(lines))


class TAPFormat():
    '''
    TAP format
    '''

    def __init__(self, printer):
        self.printer = printer

    def header(self, plan):
        '''
        Print TAP header
        '''
        self.printer.write(
            '1..{0:d}\n'.format(plan.num_operations()))

    def case(self, op):
        '''
        Print TAP test case results
        '''
        if op.status == OpState.SUCCEEDED:
            s = 'ok {0:d} {1:s}\n'.format(
                op.id_num, op)
        elif op.status == OpState.FAILED:
            s = 'not ok {0:d} {1:s}\n'.format(
                op.id_num, op)
        elif op.status == OpState.SKIPPED:
            s = 'ok {0:d} # SKIP {1:s}\n'.format(
                op.id_num, op)
        else:
            assert False

        self.printer.write(s)

        if op.message != '':
            # put '# ' at the front of each line
            message = (
                '\n'.join(
                    ['# ' + line for line in op.message.splitlines()])
                + '\n'
                )
            self.printer.write(message)

    def footer(self, plan):
        '''
        No footer
        '''
        pass


class Plan(list):
    '''
    List of operation objects.
    '''

    def run(self, dest_formatters):
        '''
        Run the operations and put the result to destination formatters
        '''

        for d in dest_formatters:
            d.header(self)

        # For each operations
        for op in self:
            op.run()

            for d in dest_formatters:
                d.case(op)

            if world['stop on failure'] and op.status == OpState.FAILED:
                world['skip all'] = True

        for d in dest_formatters:
            d.footer(self)

    def num_operations(self):
        return len(self)

    def succeeded_oparations(self):
        return filter(lambda o: o.status == OpState.SUCCEEDED, self)

    def failed_oparations(self):
        return filter(lambda o: o.status == OpState.FAILED, self)

    def skipped_operations(self):
        return filter(lambda o: o.status == OpState.SKIPPED, self)

    def total_elapsed_time(self):
        return sum([o.elapsed for o in self])

    def has_succeeded(self):
        return not len(self.failed_oparations()) > 0


if __name__ == '__main__':
    world = Environment()
    world.setup()
    tree = Tree(world['root dir'])
    plan = Planner().create_plan(tree)

    result_file = os.path.join(world['output dir'], 'result.txt')
    with open(result_file, 'w') as f:
        result_printer = TAPFormat(Printer(f))

        console = Printer(sys.stdout)
        if world['format'] == 'pretty':
            console_printer = PrettyFormat(console)
        elif world['format'] == 'TAP':
            console_printer = TAPFormat(console)

        plan.run(
            [result_printer,
             console_printer])

    if plan.has_succeeded():
        sys.exit(0)
    else:
        sys.exit(1)
