#!/usr/bin/env python2

'''
TT-Runner: a testing scripts runner
'''

import argparse
import copy
import os
import random
import re
import shutil
import signal
import stat
import subprocess
import sys
import time

# configurations
ROOT_PATH = '.'
OUTPUT_DIR = '/'

COLOR_OUTPUT = False
CHDIR = True

RANDOMIZE = False
RAND_SEED = 0
MULTIPLY_PRE = False

PRINT_LOG = False
STOP_ON_FAILURE = False
ONLY_OPS = []
SKIP_OPS = []
SKIP_ALL = False # can be changed in running

TEST_REGEX = None
RUN_REGEX = None
BEFORE_REGEX = None
AFTER_REGEX = None
BEFORE_ALL_REGEX = None
AFTER_ALL_REGEX = None

def parse_args():
    '''
    Parse command line argument and set to the configuration variables.
    '''

    parser = argparse.ArgumentParser(description=
            'A testing scripts runner')

    parser.add_argument('PATH', nargs=1,
            help='root path of the test suite')

    parser.add_argument('-o', '--output', nargs=1,
            help='directory the testing results are saved. ' +
                 'default: /tmp/tt-runner')

    parser.add_argument('--color', action='store_true',
            help='color output')

    parser.add_argument('--no-chdir', action='store_true',
            help='do not change the working directory to the directory ' +
                 'where a script exists.')

    quality_group = parser.add_argument_group(
            'options for enhancing quality of testing scripts')

    quality_group.add_argument('--randomize', nargs='?', metavar='SEED',
            type=int, default=None, const=random.randint(0,65535),
            help='randomize the order of running tests. ' +
                 'enhance independency among test cases')

    quality_group.add_argument('--multiply-preconditioning',
            action='store_true',
            help='run preconditioning scripts twice. ' +
                 'enhance idempotency of them')

    debug_group = parser.add_argument_group('options for testing of tests')

    debug_group.add_argument('--print-log', action='store_true',
            help='print the stdout and the stderr of scripts')
    debug_group.add_argument('--stop-on-failure', action='store_true',
            help='skip remaining operations if an operation fails. ' +
                 'do not run postconditioning operations.')

    skip_group = debug_group.add_mutually_exclusive_group()
    skip_group.add_argument('--only', nargs='+', metavar='N',
            type=int, default=[],
            help='run only specified operations. ' +
                 'do not run preconditioning or postconditioning operations')
    skip_group.add_argument('--skip', nargs='+', metavar='N',
            type=int, default=[],
            help='skip specified operations')
    skip_group.add_argument('--skip-all', action='store_true',
            help='skip all operations')

    prefix_group = parser.add_argument_group('options for specifying node type')

    prefix_group.add_argument('--test-regex', nargs=1, metavar='RE',
            default=['test'],
            help='regular expression matching with ' +
                 'main testing scripts\' names. ' +
                 'default: test')

    prefix_group.add_argument('--run-regex', nargs=1, metavar='RE',
            default=['run'],
            help='regular expression matching with ' +
                 'operation scripts\' names. ' +
                 'default: run')

    prefix_group.add_argument('--before-regex', nargs=1, metavar='RE',
            default=['before'],
            help='regular expression matching with ' +
                 'preconditioning scripts\' names. ' +
                 'run before each test in the same directory. ' +
                 'default: before')

    prefix_group.add_argument('--after-regex', nargs=1, metavar='RE',
            default=['after'],
            help='regular expression matching with ' +
                 'postconditioning scripts\' names. ' +
                 'run after each test in the same directory. ' +
                 'default: after')

    prefix_group.add_argument('--before-all-regex', nargs=1, metavar='RE',
            default=['before-all'],
            help='regular expression matching with ' +
                 'preconditioning scripts\' name. ' +
                 'run once before all tests in the same directory. ' +
                 'default: before-all')

    prefix_group.add_argument('--after-all-regex', nargs=1, metavar='RE',
            default=['after-all'],
            help='regular expression matching with ' +
                 'postconditioning scripts\' name. ' +
                 'run once after all tests in the same directory. ' +
                 'default: after-all')

    args = parser.parse_args()

    global ROOT_PATH
    ROOT_PATH = os.path.abspath(args.PATH[0])

    global OUTPUT_DIR
    if args.output != None:
        OUTPUT_DIR = os.path.abspath(args.output[0])
    else:
        OUTPUT_DIR = '/tmp/tt-runner'
        if os.path.lexists(OUTPUT_DIR):
            shutil.rmtree(OUTPUT_DIR)

    global COLOR_OUTPUT
    COLOR_OUTPUT = args.color

    global CHDIR
    CHDIR = not args.no_chdir

    global RANDOMIZE
    global RAND_SEED
    if args.randomize:
        RANDOMIZE = True
        RAND_SEED = args.randomize
        random.seed(RAND_SEED)
    else:
        RANDOMIZE = False
        RAND_SEED = None

    global MULTIPLY_PRE
    MULTIPLY_PRE = args.multiply_preconditioning

    global PRINT_LOG
    global STOP_ON_FAILURE
    global ONLY_OPS
    global SKIP_OPS
    global SKIP_ALL
    PRINT_LOG = args.print_log
    STOP_ON_FAILURE = args.stop_on_failure
    ONLY_OPS = args.only
    SKIP_OPS = args.skip
    SKIP_ALL = args.skip_all

    global TEST_REGEX
    global RUN_REGEX
    global BEFORE_REGEX
    global AFTER_REGEX
    global BEFORE_ALL_REGEX
    global AFTER_ALL_REGEX
    TEST_REGEX = re.compile(args.test_regex[0])
    RUN_REGEX = re.compile(args.run_regex[0])
    BEFORE_REGEX = re.compile(args.before_regex[0])
    AFTER_REGEX = re.compile(args.after_regex[0])
    BEFORE_ALL_REGEX = re.compile(args.before_all_regex[0])
    AFTER_ALL_REGEX = re.compile(args.after_all_regex[0])

class Node():
    '''
    A node of the test script tree.
    '''

    def __init__(self, path, is_leaf=False):
        # Path to file.
        self.path = os.path.abspath(path)

        # Child nodes.
        self.tests = []
        self.runs = []
        self.befores = []
        self.afters = []
        self.before_alls = []
        self.after_alls = []

        # True if the node is a file.
        self.is_leaf = is_leaf

    def __repr__(self):
        return 'Node(' + self.path + ')'

    def __str__(self):
        return os.path.relpath(self.path, ROOT_PATH)

    def is_empty(self):
        if (len(self.tests) == 0 and
            len(self.runs) == 0 and
            len(self.befores) == 0 and
            len(self.afters) == 0 and
            len(self.before_alls) == 0 and
            len(self.after_alls) == 0 and
            self.is_leaf == False):
            return True
        else:
            return False

RED = '\033[91m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
BLUE = '\033[94m'

def color(color, message):
    if COLOR_OUTPUT:
        END = '\033[0m'
        return color + message + END
    else:
        return message

class NullFile():
    def write(self, string):
        pass

class Operation():
    '''
    A unit of testing. Represent each executable script file.
    '''

    # Status
    NOT_DONE, SUCCEEDED, FAILED, SKIPPED = range(4)

    def __init__(self, path, depends):
        self.path = path
        self.depends = copy.copy(depends)
        self.status = Operation.NOT_DONE
        self.elapsed = 0.0
        self.message = ''
        self.id_num = 0 # set in create_plan

    def __repr__(self):
        return ('Operation(path=' + self.path +
                ', depends=[' +
                ','.join([str(d) for d in self.depends]) +
                '], status=' + self.status + ')')

    def __str__(self):
        return os.path.relpath(self.path, ROOT_PATH)

    def logfile_name(self):
        assert self.id_num > 0
        return str(self.id_num) + '.' + str(self).replace(os.sep, '.') + '.out'

    def run(self):
        '''
        Exec this operation.
        The result is set into field variables.
        '''

        if SKIP_ALL:
            self.status = Operation.SKIPPED
            return

        if self.id_num in SKIP_OPS:
            self.status = Operation.SKIPPED
            return

        if len(ONLY_OPS) > 0 and self.id_num not in ONLY_OPS:
            self.status = Operation.SKIPPED
            return

        # Skip if depending operation did not succeed.
        for depend_op in self.depends:
            assert depend_op.status != Operation.NOT_DONE
            if depend_op.status != Operation.SUCCEEDED:
                self.status = Operation.SKIPPED
                self.message = ('skipped because ' + str(depend_op) +
                                ' did not succeed.')
                return

        # Skip if the file is not executable.
        if not os.access(self.path, os.R_OK | os.X_OK):
            self.status = Operation.SKIPPED
            self.message = str(self) + ' is not executable.'
            return

        console = None
        if PRINT_LOG:
            console = sys.stderr
        else:
            console = NullFile()

        console.write(color(BLUE, '\n# run {0:s}\n'.format(self)))

        if CHDIR:
            # Change the working directory to the directory where
            # the script exists.
            os.chdir(os.path.dirname(self.path))

        start = time.time()

        process = None
        try:
            process = subprocess.Popen([self.path],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT)
            logfile = os.path.join(OUTPUT_DIR, self.logfile_name())

            # write stdout and stderr of the operation
            # to stderr and logfile
            with process.stdout, open(logfile, 'wb') as f:
                for line in iter(process.stdout.readline, b''):
                    f.write(line)
                    console.write(line)

            process.wait()

        except OSError as e:
            # For the case when the script at the path has not shebang.
            self.status = Operation.FAILED
            self.message = ('OSError: ' + str(e) + '\n' +
                            'Is the shebang correct?')
            return

        except KeyboardInterrupt as i:
            process.send_signal(signal.SIGINT)
            process.wait()
            self.message = 'KeyboardInterrupt'

        end = time.time()
        self.elapsed = end - start

        if process.returncode != 0:
            self.status = Operation.FAILED
        else:
            self.status = Operation.SUCCEEDED

def create_tree(path):
    '''
    Return node object that represents the path.
    '''

    def get_child_node(child_path):
        if os.path.isfile(child_path):
            return Node(child_path, is_leaf=True)
        else:
            child_node = create_tree(child_path)
            if child_node.is_empty():
                return None
            else:
                return child_node

    node = Node(path)
    for entry in os.listdir(path):
        child_path = os.path.join(path, entry)

        # If the directory entry has one of prefixes,
        # add it to the child nodes.

        if TEST_REGEX.match(entry):
            child_node = get_child_node(child_path)
            if child_node == None:
                continue
            node.tests.append(child_node)

        elif RUN_REGEX.match(entry):
            child_node = get_child_node(child_path)
            if child_node == None:
                continue
            node.runs.append(child_node)

        # Before-all and after-all prefixes have higher priority
        # than before and after prefixes.
        elif BEFORE_ALL_REGEX.match(entry):
            child_node = get_child_node(child_path)
            if child_node == None:
                continue
            node.before_alls.append(child_node)

        elif AFTER_ALL_REGEX.match(entry):
            child_node = get_child_node(child_path)
            if child_node == None:
                continue
            node.after_alls.append(child_node)

        elif BEFORE_REGEX.match(entry):
            child_node = get_child_node(child_path)
            if child_node == None:
                continue
            node.befores.append(child_node)

        elif AFTER_REGEX.match(entry):
            child_node = get_child_node(child_path)
            if child_node == None:
                continue
            node.afters.append(child_node)

    return node

def create_plan(root_node):
    '''
    Return a list of operations.
    '''

    def randomize_nodes(in_nodes):
        if not RANDOMIZE:
            return sorted_nodes(in_nodes)
        out_nodes = copy.copy(in_nodes)
        random.shuffle(out_nodes)
        return out_nodes

    def sorted_nodes(in_nodes):
        return sorted(in_nodes, key=lambda node: node.path)

    def revsorted_nodes(in_nodes):
        return sorted(in_nodes, key=lambda node: node.path, reverse=True)

    def get_before_all_ops(node, depends):
        my_depends = copy.copy(depends)
        before_all_ops = []
        for before_all_node in sorted_nodes(node.before_alls):
            ops = visit(before_all_node, my_depends)
            before_all_ops.extend(ops)
            # Depends previous before-all operations.
            my_depends.extend(ops)
        return before_all_ops

    def get_after_all_ops(node, depends):
        after_all_ops= []
        for after_all_node in revsorted_nodes(node.after_alls):
            ops = visit(after_all_node, depends)
            after_all_ops.extend(ops)
        return after_all_ops

    def get_before_ops(node, depends):
        my_depends = copy.copy(depends)
        before_ops = []
        for before_node in sorted_nodes(node.befores):
            ops = visit(before_node, my_depends)
            before_ops.extend(ops)
            # Depends previous before operations.
            my_depends.extend(ops)
        return before_ops

    def get_after_ops(node, depends):
        after_ops= []
        for after_node in revsorted_nodes(node.afters):
            ops = visit(after_node, depends)
            after_ops.extend(ops)
        return after_ops

    def visit(node, depends):
        '''
        Visit nodes recursively and return the list of operations
        under the node.
        '''

        # Tree is end.
        if node.is_leaf:
            op = Operation(node.path, depends)
            return [op]

        # Operations in the nodes under this node.
        ops_under_node = []

        # before-all nodes
        before_all_ops = get_before_all_ops(node, depends)
        ops_under_node.extend(before_all_ops)
        my_depends_out = copy.copy(depends)
        my_depends_out.extend(before_all_ops)

        if MULTIPLY_PRE:
            before_all_ops2 = get_before_all_ops(node, my_depends_out)
            ops_under_node.extend(before_all_ops2)
            my_depends_out.extend(before_all_ops2)

        # note: temporary execcute before-operations and after-operations
        # respectively before and after run-operations. In the future, we
        # might prohibit that a node contains both of run-operations and
        # other operations.
        if len(node.runs) > 0:
            # before nodes
            before_ops = get_before_ops(node, my_depends_out)
            ops_under_node.extend(before_ops)
            my_depends_in = copy.copy(my_depends_out)
            my_depends_in.extend(before_ops)

            # run nodes
            for run_node in sorted_nodes(node.runs):
                run_ops = visit(run_node, my_depends_in)
                ops_under_node.extend(run_ops)
                my_depends_in.extend(run_ops)

            # after nodes
            after_ops = get_after_ops(node, my_depends_out)
            ops_under_node.extend(after_ops)

        first_test = True
        for test_node in randomize_nodes(node.tests):
            # before nodes
            before_ops = get_before_ops(node, my_depends_out)
            ops_under_node.extend(before_ops)
            my_depends_in = copy.copy(my_depends_out)
            my_depends_in.extend(before_ops)

            if MULTIPLY_PRE and first_test:
                before_ops2 = get_before_ops(node, my_depends_in)
                ops_under_node.extend(before_ops2)
                my_depends_in.extend(before_ops2)
                first_test = False

            # test node
            test_ops = visit(test_node, my_depends_in)
            ops_under_node.extend(test_ops)

            # after nodes
            after_ops = get_after_ops(node, my_depends_out)
            ops_under_node.extend(after_ops)

        # after-all nades
        after_all_ops = get_after_all_ops(node, depends)
        ops_under_node.extend(after_all_ops)

        return ops_under_node

    depends = []
    operations = visit(root_node, depends)

    # Set id numbers of operations
    for i in range(len(operations)):
        operations[i].id_num = i + 1

    return operations

def set_env_vars():
    '''
    Set environment variables.
    They are used in testing scripts to be executed.
    '''

    os.environ["TT_RUNNER_EXEC_DIR" ] = os.getcwd()
    os.environ["TT_RUNNER_ROOT_DIR" ] = ROOT_PATH
    os.environ["TT_RUNNER_OUTPUT_DIR"] = OUTPUT_DIR

def run_ops(operations):
    '''
    Run operations.
    '''

    tapfile = os.path.join(OUTPUT_DIR, 'result.txt')
    with open(tapfile, 'w') as f:

        num_ops = len(operations)
        line = '1..{0:d}'.format(num_ops)
        print color(GREEN, line)
        f.write(line + '\n')

        # For each operations
        for i in range(1, num_ops + 1):
            op = operations[i - 1]
            op.run()

            # Format message
            message = ''
            if op.message != '':
                message = '\n' + '\n'.join(
                      ['# ' + line for line in op.message.splitlines()])

            if op.status == Operation.SUCCEEDED:
                line = 'ok {0:d} {1:s}{2:s}'.format(
                        i, op, message)
                print color(GREEN, line)
                f.write(line + '\n')

            elif op.status == Operation.FAILED:
                line = 'not ok {0:d} {1:s}{2:s}'.format(
                        i, op, message)
                print color(RED, line)
                f.write(line + '\n')

            elif op.status == Operation.SKIPPED:
                line = 'ok {0:d} {1:s} # SKIP{2:s}'.format(i, op, message)
                print color(YELLOW, line)
                f.write(line + '\n')

            else:
                assert False

            if STOP_ON_FAILURE and op.status == Operation.FAILED:
                global SKIP_ALL
                SKIP_ALL = True

def summarize(operations):
    '''
    Print the summary of operations.
    Return False if one or more operations are failed.
    '''

    num_test = len(operations)
    num_sunceeded = len(filter(
        lambda o : o.status == Operation.SUCCEEDED, operations))
    num_failed = len(filter(
        lambda o : o.status == Operation.FAILED, operations))
    num_skipped = len(filter(
        lambda o : o.status  == Operation.SKIPPED, operations))
    elapsed = sum([ o.elapsed for o in operations ])

    message = ('\n' +
               '# operations = ' + str(num_test) + '\n' +
               '# succeeded = ' + str(num_sunceeded) + '\n' +
               '# failed = ' + str(num_failed) + '\n' +
               '# skipped = ' + str(num_skipped) + '\n' +
               '# time-taken = {0:.0f} [sec]'.format(elapsed))

    if RANDOMIZE:
        message += '\n# random-seed = {0:d}'.format(RAND_SEED)

    print >> sys.stderr, color(BLUE, message)

    if num_failed > 0:
        return False
    else:
        return True

if __name__ == '__main__':
    parse_args()
    os.makedirs(OUTPUT_DIR)
    root_node = create_tree(ROOT_PATH)
    operations = create_plan(root_node)
    set_env_vars()
    run_ops(operations)
    is_success = summarize(operations)
    if not is_success:
        sys.exit(1)
