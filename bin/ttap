#!/usr/bin/env python
# coding: utf-8

'''ttap: a testing framework with file system hierarchy'''

from abc import ABCMeta, abstractmethod
from argparse import ArgumentParser
from io import IOBase
import itertools
import codecs
from copy import copy
import os
import random
import re
import shutil
from signal import SIGINT
from subprocess import Popen, PIPE, STDOUT
import sys
from time import time

# global configuration object
world = None

# default configuration values
default = {
    'version': 'ttap 0.1',
    'output dir': '/tmp/ttap',
    'test regex': r'^test',
    'run regex': r'^run',
    'before regex': r'^before',
    'after regex': r'^after',
    'init regex': r'^init',
    'final regex': r'^final',
    'tap regex': r'^.+\.(bats|t)$',
    }


class MyParser(ArgumentParser):
    '''ttap's argument parser'''

    def __new__(cls):
        '''Create my parser. Define options and usage document.'''

        parser = ArgumentParser(
            description='a testing framework with file system hierarchy')

        parser.add_argument(
            '-v', '--version',
            action='version',
            version=default['version'])

        parser.add_argument(
            'PATH',
            nargs=1,
            help="path to a test suite's root directory")
        d = default['output dir']
        parser.add_argument(
            '-o', '--output',
            metavar='PATH',
            nargs=1,
            default=[d],
            help=('path to a directory saving the result. '
                  'default: {0}').format(d))

        parser.add_argument(
            '--tap',
            action='store_true',
            default=False,
            help='show result with TAP format')

        parser.add_argument(
            '--color', default='auto', metavar='M',
            choices=['auto', 'always', 'never'],
            help="color mode. 'auto' (default), 'always', or 'never'")

        parser.add_argument(
            '--no-change-dir',
            action='store_true',
            help='do not change the working directory')

        quality_group = parser.add_argument_group(
            'options for improvement of test suites')
        quality_group.add_argument(
            '--randomize',
            metavar='SEED',
            nargs='?',
            type=int,
            default=None,  # it means this options is not set
            const=random.randint(0, 65535),
            help='randomize the order of running tests')
        quality_group.add_argument(
            '--multiply-preconditioning',
            action='store_true',
            help='run preconditioning scripts twice in a row')

        debug_group = parser.add_argument_group(
            'options for testing of test suites')
        debug_group.add_argument(
            '--print-log',
            action='store_true',
            help='print stdout and stderr of running scripts')
        debug_group.add_argument(
            '--stop-on-failure',
            action='store_true',
            help='skip remaining operations if an operation fails')

        skip_group = debug_group.add_mutually_exclusive_group()
        skip_group.add_argument(
            '--skip-all',
            action='store_true',
            help='skip all operations')
        skip_group.add_argument(
            '--only',
            metavar='NAME',
            nargs='+',
            type=str,
            default=[],
            help='run only specified scripts')
        skip_group.add_argument(
            '--skip',
            metavar='NAME',
            nargs='+',
            type=str,
            default=[],
            help='skip specified scripts')

        prefix_group = parser.add_argument_group(
            'regular expressions for classifying node types')
        d = default['test regex']
        prefix_group.add_argument(
            '--test-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with test-nodes. '
                  'default: {0}').format(d))
        d = default['run regex']
        prefix_group.add_argument(
            '--run-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with run-nodes. '
                  'default: {0}').format(d))
        d = default['before regex']
        prefix_group.add_argument(
            '--before-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with before-nodes. '
                  'default: {0}').format(d))
        d = default['after regex']
        prefix_group.add_argument(
            '--after-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with after-nodes. '
                  'default: {0}').format(d))
        d = default['init regex']
        prefix_group.add_argument(
            '--init-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with init-nodes. '
                  'default: {0}').format(d))
        d = default['final regex']
        prefix_group.add_argument(
            '--final-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with final-nodes. '
                  'default: {0}').format(d))

        protocol_group = parser.add_argument_group(
            'regular expressions for classifying output protocols')
        d = default['tap regex']
        protocol_group.add_argument(
            '--tap-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with script files which output '
                  'are formatted with Test Anything Protocol. '
                  'default: {0}').format(d))

        return parser


class Environment(dict):
    '''Dictionary of configuration properties'''

    def __init__(self):
        args = MyParser().parse_args()

        self['root dir'] = os.path.abspath(args.PATH[0])
        self['output dir'] = os.path.abspath(args.output[0])

        if args.tap is True:
            self['format'] = 'TAP'
        else:
            self['format'] = 'pretty'

        if args.color == 'always':
            self['color output'] = True
        elif args.color == 'never':
            self['color output'] = False
        elif args.color == 'auto':
            self['color output'] = sys.stdout.isatty()

        self['change dir'] = not args.no_change_dir

        ## Quality options

        # when --randomize option is assigned
        if args.randomize:
            self['randomize'] = True
            self['random seed'] = args.randomize
            random.seed(args.randomize)
        else:
            self['randomize'] = False

        self['multiply preconditioning'] = args.multiply_preconditioning

        ## Testing for test options

        self['print log'] = args.print_log
        self['stop on failure'] = args.stop_on_failure

        # note: can be changed in running
        self['skip all'] = args.skip_all

        # absolute paths of only-run files or directory
        self['only list'] = [os.path.join(self['root dir'], n)
                             for n in args.only]
        # absolute paths of skipped files
        self['skip list'] = [os.path.join(self['root dir'], n)
                             for n in args.skip]

        for p in self['skip list'] + self['only list']:
            if not os.path.exists(p):
                raise MyError("No such file or directory: '{0}'"
                              .format(os.path.relpath(p)))

        ## Regex options

        self['test regex'] = re.compile(args.test_regex[0])
        self['run regex'] = re.compile(args.run_regex[0])
        self['before regex'] = re.compile(args.before_regex[0])
        self['after regex'] = re.compile(args.after_regex[0])
        self['init regex'] = re.compile(args.init_regex[0])
        self['final regex'] = re.compile(args.final_regex[0])

        self['tap regex'] = re.compile(args.tap_regex[0])

    def setup(self):
        '''Set up the environment'''
        # for repeatable running, cleanup the output directory
        # if -o option is not assigned
        d = default['output dir']
        if self['output dir'] == d:
            if os.path.lexists(d):
                try:
                    shutil.rmtree(d)
                except OSError as e:
                    raise MyError(e)

        # create the output directory
        try:
            os.makedirs(self['output dir'])
        except OSError as e:
            raise MyError(e)

        # set environment variables in the process
        os.environ['TTAP_EXEC_DIR'] = os.getcwd()
        os.environ['TTAP_ROOT_DIR'] = self['root dir']
        os.environ['TTAP_OUTPUT_DIR'] = self['output dir']

        # If a relative path is set in PATH environment variable,
        # reset the absolute path to PATH. This is for the case
        # where a user set relative path to Bats and ttap losts it
        # as changing working directory.
        # If this is considered to be interfering, this will be removed.
        if self['change dir']:
            paths = os.environ['PATH'].split(':')
            new_paths = []
            for p in paths:
                if os.path.isabs(p):
                    new_paths.append(p)
                else:
                    new_paths.append(os.path.abspath(p))
            os.environ['PATH'] = ':'.join(new_paths)


class Path():
    '''Value object of path string'''

    def __init__(self, path_string):
        self.path_string = os.path.abspath(path_string)

    def __lt__(self, other):
        return self.path_string < other.path_string

    def __gt__(self, other):
        return self.path_string > other.path_string

    def __eq__(self, other):
        return self.path_string == other.path_string

    def __le__(self, other):
        return self.path_string <= other.path_string

    def __ge__(self, other):
        return self.path_string >= other.path_string

    def __ne__(self, other):
        return self.path_string != other.path_string

    def __str__(self):
        return os.path.relpath(self.path_string, world["root dir"])

    def abspath(self):
        '''Return the absolute path string'''
        return self.path_string

    def normalized(self):
        '''Return the relative path from the root directory
        of the test suite'''
        return str(self)

    def basename(self):
        '''Return the file name'''
        return os.path.basename(self.path_string)

    def dirname(self):
        '''Return the directory name where the file exists'''
        return os.path.dirname(self.path_string)

    def is_executable(self):
        '''Return True if the file is executable'''
        return os.access(self.path_string, os.R_OK | os.X_OK)

    def startswith(self, path_string):
        '''Return True if the path starts with the given path string'''
        assert os.path.isabs(path_string)
        return self.path_string.startswith(path_string)


class Node():
    '''A node of the scripts tree, a directory'''

    def __init__(
            self, path,
            tests, runs,
            befores, afters,
            inits, finals):

        self.path = path

        # child nodes
        self.tests = tests
        self.runs = runs
        self.befores = befores
        self.afters = afters
        self.inits = inits
        self.finals = finals

    def __str__(self):
        return str(self.path)

    def name(self):
        '''Get the directory or file name'''
        return self.path.basename()

    def is_empty(self):
        '''Return True if this node does not have child nodes'''
        if (self.tests and self.runs and
                self.befores and self.afters and
                self.inits and self.finals):
            return True
        else:
            return False

    def accept(self, visitor):
        visitor.visit_node(self)


class Leaf():
    '''A script file'''

    def __init__(self, path):
        self.path = path

    def __str__(self):
        return str(self.path)

    def name(self):
        return self.path.basename()

    def is_empty(self):
        return False

    def accept(self, visitor):
        visitor.visit_leaf(self)


class NodeGroup(list):
    '''Abstract class of node object list'''

    __metaclass__ = ABCMeta

    def randomized(self):
        '''Return randomized node list'''
        out = self.sorted()
        if world['randomize']:
            random.shuffle(out)
        return out

    def sorted(self, reverse=False):
        '''Return node list sorted by path name'''
        return sorted(self, key=lambda node: node.path, reverse=reverse)

    @abstractmethod
    def accept(self, visitor):
        pass


class TestGroup(NodeGroup):
    '''List of test-nodes'''
    def accept(self, visitor):
        visitor.visit_test_group(self)


class RunGroup(NodeGroup):
    '''List of run-nodes'''
    def accept(self, visitor):
        visitor.visit_run_group(self)


class BeforeGroup(NodeGroup):
    '''List of before-nodes'''
    def accept(self, visitor):
        visitor.visit_before_group(self)


class AfterGroup(NodeGroup):
    '''List of after-nodes'''
    def accept(self, visitor):
        visitor.visit_after_group(self)


class InitGroup(NodeGroup):
    '''List of init-nodes'''
    def accept(self, visitor):
        visitor.visit_init_group(self)


class FinalGroup(NodeGroup):
    '''List of final-nodes'''
    def accept(self, visitor):
        visitor.visit_final_group(self)


class Tree():
    '''A tree of node objects

    It traces the directory structure of the test suites.'''

    def __init__(self, root_path):
        '''Create tree'''
        try:
            self.root_node = self.__create_nodes(root_path)
        except OSError as e:
            raise MyError(e)

    class __StringFormatter():
        '''Format string from Tree object'''

        def get_string(self, tree):
            '''Return string object'''
            self.string = ''
            self.indent = ''
            tree.root_node.accept(self)
            return self.string

        def visit_node(self, node):
            self.string += self.indent + '- ' + node.name() + '\n'

            indent_copy = copy(self.indent)
            self.indent += '  '

            node.inits.accept(self)
            node.befores.accept(self)
            node.runs.accept(self)
            node.tests.accept(self)
            node.afters.accept(self)
            node.finals.accept(self)

            self.indent = indent_copy

        def visit_leaf(self, leaf):
            self.string += self.indent + '- ' + leaf.name() + '\n'

        def visit_test_group(self, test_group):
            for test in test_group.sorted():
                test.accept(self)

        def visit_run_group(self, run_group):
            for run in run_group.sorted():
                run.accept(self)

        def visit_before_group(self, before_group):
            for before in before_group.sorted():
                before.accept(self)

        def visit_after_group(self, after_group):
            for after in after_group.sorted(reverse=True):
                after.accept(self)

        def visit_init_group(self, init_group):
            for init in init_group.sorted():
                init.accept(self)

        def visit_final_group(self, final_group):
            for final in final_group.sorted(reverse=True):
                final.accept(self)

    def __str__(self):
        return Tree.__StringFormatter().get_string(self)

    def __create_nodes(self, path):
        '''Create node objects under the path recursively
        and return a node object that represents the path'''

        if os.path.isfile(path):
            return Leaf(Path(path))

        def __create_child_nodes(childs, regex):
            names = filter(lambda n: regex.match(n), childs)
            pathes = map(lambda n: os.path.join(path, n), names)
            nodes = map(lambda p: self.__create_nodes(p), pathes)
            non_empty_nodes = filter(lambda n: not n.is_empty(), nodes)
            return non_empty_nodes

        childs = os.listdir(path)

        tests = TestGroup()
        nodes = __create_child_nodes(childs, world['test regex'])
        tests.extend(nodes)

        runs = RunGroup()
        nodes = __create_child_nodes(childs, world['run regex'])
        runs.extend(nodes)

        befores = BeforeGroup()
        nodes = __create_child_nodes(childs, world['before regex'])
        befores.extend(nodes)

        afters = AfterGroup()
        nodes = __create_child_nodes(childs, world['after regex'])
        afters.extend(nodes)

        inits = InitGroup()
        nodes = __create_child_nodes(childs, world['init regex'])
        inits.extend(nodes)

        finals = FinalGroup()
        nodes = __create_child_nodes(childs, world['final regex'])
        finals.extend(nodes)

        return Node(Path(path), tests, runs,
                    befores, afters, inits, finals)


class Printer():
    '''A message printer'''

    __color_head = {
        'red': '\033[91m',
        'green': '\033[92m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
    }

    def __init__(self, out):
        '''Initialize a printer with a file object'''
        self.out = out

    def write(self, message, color=None):
        '''Write a message to the file with color'''
        if world['color output'] and color:
            end = '\033[0m'
            message = Printer.__color_head[color] + message + end
        self.out.write(message)
        self.out.flush()


class NullFile(IOBase):
    '''Null file object

    only write and flush method can be used'''

    def __init__(self):
        pass

    def write(self, string):
        pass

    def flush(self):
        pass


class CaseResult():
    '''Result of test case'''

    (SUCCEEDED,
     FAILED,
     SKIPPED) = range(3)

    def __init__(self, status, description, message):
        assert (status == self.SUCCEEDED or
                status == self.FAILED or
                status == self.SKIPPED)

        self.status = status
        self.description = description
        self.message = message


class Protocol():
    '''Abstract class of protocol that scripts obey'''

    __metaclass__ = ABCMeta

    def set_format(self, out_format):
        '''Set a format which output is printed with'''
        self.out_format = out_format

    def set_operation_name(self, name):
        '''Set an operation name'''
        self.opname = name

    @abstractmethod
    def decode_stdout(self, iterable_lines):
        '''Analyze output of a script'''
        pass

    @abstractmethod
    def decode_statuscode(self, statuscode):
        '''Analyze a status code a script returns'''
        pass

    @abstractmethod
    def get_results(self):
        '''Return CaseResult objects'''
        pass


class StandardProtocol(Protocol):
    '''Simple protocol

    Operations succeed when scripts exit with a zero status.
    Operations fail when scripts exit with a non-zero status.'''

    def decode_stdout(self, iterable_lines):
        '''Print stdout to console when --print-log option is set'''

        if world['print log']:
            console = Printer(sys.stderr)
        else:
            console = Printer(NullFile())

        console.write(
            '\n➤ {0:s}\n'.format(self.opname),
            'blue')

        for line in iterable_lines:
            console.write(line)

    def decode_statuscode(self, statuscode):
        '''The operation fails if it returns non-zero status code'''

        if statuscode == 0:
            status = CaseResult.SUCCEEDED
        else:
            status = CaseResult.FAILED

        result = CaseResult(status, self.opname, '')
        self.out_format.print_case_result(result)
        self.results = [result]

    def get_results(self):
        return self.results


class TestAnythingProtocol(Protocol):
    '''Test Anything Protocol (TAP)'''

    RE_PLAN = re.compile(r'^1\.\.(\d+)(.*)$')
    RE_OK = re.compile(r'^ok\s+(\d+)(\s+-)?\s+(.*)$')
    RE_NOT_OK = re.compile(r'^not\sok\s+(\d+)(\s+-)?\s+(.*)$')
    RE_SKIP = re.compile(r'^ok\s+(\d+)(\s+-)?\s+(# (SKIP|skip|Skip))\s+(.*)$')
    RE_COMMENT = re.compile(r'^#\s(.*)$')
    RE_BAILOUT = re.compile(r'^Bail\sout!(.*)$')

    def __init__(self):
        self.results = []
        self.failed = False
        self.bailouted = False

    def decode_stdout(self, iterable_lines):
        '''Decode TAP-formatted result'''

        # TODO: validate protocol

        for line in iterable_lines:

            if self.RE_PLAN.match(line):
                continue

            if self.RE_SKIP.match(line):
                result = CaseResult(
                    CaseResult.SKIPPED,
                    self.opname + ': ' + self.RE_SKIP.match(line).group(5),
                    '')

                self.out_format.print_case_result(result)
                self.results.append(result)
                self.failed = True
                continue

            if self.RE_OK.match(line):
                result = CaseResult(
                    CaseResult.SUCCEEDED,
                    self.opname + ': ' + self.RE_OK.match(line).group(3),
                    '')

                self.out_format.print_case_result(result)
                self.results.append(result)
                continue

            if self.RE_NOT_OK.match(line):
                result = CaseResult(
                    CaseResult.FAILED,
                    self.opname + ': ' + self.RE_NOT_OK.match(line).group(3),
                    '')

                self.out_format.print_case_result(result)
                self.results.append(result)
                self.failed = True
                continue

            if self.RE_COMMENT.match(line):
                self.out_format.print_message_line(
                    self.RE_COMMENT.match(line).group(1))
                continue

            if self.RE_BAILOUT.match(line):
                result = CaseResult(
                    CaseResult.FAILED,
                    self.opname,
                    line)

                self.out_format.print_case_result(result)
                self.results.append(result)
                self.bailouted = True
                return

    def decode_statuscode(self, statuscode):
        '''Print a failure message only if the script exits with
        a non-zero status code but all tests succeed'''

        if self.bailouted:
            return
        if self.failed:
            return
        if statuscode == 0:
            return

        result = CaseResult(
            CaseResult.FAILED,
            self.opname,
            '')
        self.out_format.print_case_result(result)
        self.results.append(result)

    def get_results(self):
        return self.results


class Operation():
    '''A unit of testing

    It represent each executable script file.'''

    def __init__(self, path, depends, protocol):
        self.path = path
        self.depends = copy(depends)

        self.has_done = False
        self.elapsed = 0.0
        self.case_results = None

        # unique number among all operations
        self.id_num = 0

        # unique number among operations with the same file
        # 1 or more value is set if a file associated to
        # two or more operations.
        self.serial_num = 0

        self.protocol = protocol

    def set_id(self, id_num):
        assert self.id_num == 0
        assert id_num > 0
        self.id_num = id_num

    def set_serial(self, serial_num):
        assert self.serial_num == 0
        assert serial_num > 0
        self.serial_num = serial_num

    def __str__(self):
        if self.serial_num > 0:
            return '{0:s}.{1:d}'.format(
                str(self.path), self.serial_num)
        else:
            return str(self.path)

    def logfile_name(self):
        '''Get the name of the log file
        where the output of this operation is printed'''

        return '{0:s}.out'.format(
            str(self).replace(os.sep, '.'))

    def has_succeeded(self):
        '''Return True if all test cases have succeeded'''

        for result in self.case_results:
            if result.status != CaseResult.SUCCEEDED:
                return False

        return True

    def has_failed(self):
        '''Return True if one or more test cases have failed
        (not succeeded and notskipped)'''

        for result in self.case_results:
            if result.status == CaseResult.FAILED:
                return True

        return False

    def run(self, out_format):
        '''Exec this operation

        The result is printed to the out format and set
        in field variables.'''

        assert self.id_num > 0
        assert not self.has_done
        assert self.case_results is None

        self.__out_format = out_format

        # check this operation is to be skipped
        # or to fail before execution
        to_skip, message = self.__to_be_skipped()
        if to_skip:
            self.__abort(CaseResult.SKIPPED, message)
            return

        to_fail, message = self.__to_fail()
        if to_fail:
            self.__abort(CaseResult.FAILED, message)
            return

        # if change-dir mode, change the working directory
        # to the directory where the script exists.
        if world['change dir']:
            os.chdir(self.path.dirname())

        start = time()

        self.protocol.set_format(out_format)
        self.protocol.set_operation_name(str(self))

        logfile = os.path.join(
            world['output dir'], self.logfile_name())

        # write stdout and stderr of the operation to logfile
        with codecs.open(logfile, mode='w', encoding='utf8') as log:

            log.write("file: {0}\n".format(str(self.path)))
            log.write("\n--- output start ---\n")

            try:
                process = Popen(
                    [self.path.abspath()],
                    stdout=PIPE,
                    stderr=STDOUT)

                def readline():
                    # expect the process output with UTF-8 encoding
                    line = process.stdout.readline().decode('utf8')
                    # write stdout to log file when read
                    log.write(line)
                    return line

                iterator = iter(readline, '')

                self.protocol.decode_stdout(iterator)
                process.wait()

            except OSError as e:
                # For the case when the script has a wrong shebang
                message = (str(e) + '\n'
                           'Is the shebang correct?')
                self.__abort(CaseResult.FAILED, message)
                return

            except ValueError as e:
                message = (str(e) + '\n'
                           'UTF-8 encoding is expected')
                self.__abort(CaseResult.FAILED, message)
                return

            except KeyboardInterrupt as i:
                process.send_signal(SIGINT)
                process.wait()
                message = 'KeyboardInterrupt'
                self.__abort(CaseResult.FAILED, message)
                return

            finally:
                log.write("--- output end ---\n\n")

            status = process.returncode
            log.write("status code: {0:d}\n".format(status))
            self.protocol.decode_statuscode(status)
            self.case_results = self.protocol.get_results()

            taken_time = time() - start
            self.elapsed = taken_time
            log.write("taken time : {0:f} sec\n".format(taken_time))

        self.has_done = True

    def __to_be_skipped(self):
        '''Return whether this operation is to be skipped,
        and a message'''

        if world['skip all']:
            return True, ''

        # skip if the path of the operation is
        # under the directory in skip list
        for skip_file in world['skip list']:
            if self.path.startswith(skip_file):
                return True, ''

        # skip if the path of the operation is
        # under the directory in only list
        if len(world['only list']) > 0:
            for only_file in world['only list']:
                if self.path.startswith(only_file):
                    return False, None
            else:
                return True, ''

        # Skip if depending operation did not succeed.
        for depend_op in self.depends:
            assert depend_op.has_done
            if not depend_op.has_succeeded():
                message = (
                    'depending operation did not succeed: {0:s}'
                    .format(str(depend_op)))
                return True, message

        return False, None

    def __to_fail(self):
        '''Return whether this operation is to fail and a message'''
        # Fail if the file is not executable.
        if not self.path.is_executable():
            message = '{0:s} is not executable.'.format(str(self.path))
            return True, message
        else:
            return False, None

    def __abort(self, status, message):
        '''Stop this operation'''
        result = CaseResult(status, str(self), message)
        self.__out_format.print_case_result(result)
        self.case_results = [result]
        self.has_done = True


class Planner():
    '''Create an operation plan'''

    # use the visitor design patten.
    # this visits Node class and NodeGroup class recursively.

    def create_plan(self, tree):
        '''Return a plan object'''

        self.planned_operations = Plan()
        self.depended_operations = []
        tree.root_node.accept(self)
        assert len(self.depended_operations) == 0

        # set id numbers
        id_num = 0
        for op in self.planned_operations:
            id_num += 1
            op.set_id(id_num)

        # set serial numbers
        for op in self.planned_operations:
            c = list(filter(
                lambda o: o.path == op.path, self.planned_operations))
            assert len(c) > 0
            if len(c) == 1:
                continue
            n = max(map(lambda o: o.serial_num, c))
            op.set_serial(n + 1)

        return self.planned_operations

    def visit_node(self, node):
        '''Define the relations between node types'''

        # accept method must be sandwiched between __set and __reset.
        __m = []

        def __set(list):
            '''Remember the current state '''
            __m.append(len(list))

        def __reset(list):
            ''' Reset to the remembered state '''
            length = __m.pop()
            del list[length:]

        __set(self.depended_operations)

        node.inits.accept(self)
        if world['multiply preconditioning']:
            node.inits.accept(self)

        # note: temporary execute before-operations and after-operations
        # respectively before and after run-operations. In the future, we
        # might prohibit that a node contains both of run-operations and
        # other operations.

        if len(node.runs) > 0:
            __set(self.depended_operations)

            node.befores.accept(self)
            node.runs.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        first_test = True
        for test in node.tests.randomized():
            __set(self.depended_operations)

            node.befores.accept(self)
            if world['multiply preconditioning'] and first_test:
                node.befores.accept(self)
            first_test = False

            test.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        __reset(self.depended_operations)
        __set(self.depended_operations)

        node.finals.accept(self)

        __reset(self.depended_operations)

    def visit_leaf(self, leaf):
        '''Add new operation object'''

        if world['tap regex'].match(leaf.path.basename()):
            protocol = TestAnythingProtocol()
        else:
            protocol = StandardProtocol()

        operation = Operation(
            leaf.path,
            self.depended_operations,
            protocol)
        self.planned_operations.append(operation)
        self.depended_operations.append(operation)

    def visit_test_group(self, test_group):
        '''This planner do not do not visit test-group'''
        assert False

    def visit_run_group(self, run_group):
        '''Visit run-nodes in the sequential order'''
        for run_node in run_group.sorted():
            run_node.accept(self)

    def visit_before_group(self, before_group):
        '''Visit before-nodes in the sequential order'''
        for before_node in before_group.sorted():
            before_node.accept(self)

    def visit_after_group(self, after_group):
        '''Visit after-nodes in the reversed order'''
        for after_node in after_group.sorted(reverse=True):
            after_node.accept(self)

    def visit_init_group(self, init_group):
        '''Visit init-nodes in the sequential order'''
        for init_node in init_group.sorted():
            init_node.accept(self)

    def visit_final_group(self, final_group):
        '''Visit final-nodes in the sequential order'''
        for final_node in final_group.sorted(reverse=True):
            final_node.accept(self)


class Format:
    '''Output format of test results'''

    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, printer):
        pass

    @abstractmethod
    def print_header(self, plan):
        '''Print header message'''
        pass

    @abstractmethod
    def print_case_result(self, case_result):
        '''Print a result of a test case'''
        pass

    @abstractmethod
    def print_message_line(self, line):
        '''Print a message line'''
        pass

    @abstractmethod
    def print_footer(self, plan):
        '''Print footer message'''
        pass


class PrettyFormat(Format):
    '''Pretty format'''

    def __init__(self, printer):
        self.printer = printer

    def print_header(self, plan):
        '''Pretty format has no header'''
        pass

    def print_case_result(self, case_result):
        '''Print pretty test case result'''

        if case_result.status == CaseResult.SUCCEEDED:
            s = '✓ {0:s}\n'.format(case_result.description)
            self.printer.write(s, 'green')
        elif case_result.status == CaseResult.FAILED:
            s = '✗ {0:s}\n'.format(case_result.description)
            self.printer.write(s, 'red')
        elif case_result.status == CaseResult.SKIPPED:
            s = '− {0:s}\n'.format(case_result.description)
            self.printer.write(s, 'yellow')
        else:
            assert False

        if case_result.message != '':
            message = '\n'.join(
                ['  ' + line for line
                    in case_result.message.splitlines()]) + '\n'
            self.printer.write(message)

    def print_message_line(self, line):
        '''Print a message line with a indent'''
        self.printer.write('  ' + line + '\n')

    def print_footer(self, plan):
        '''Print summury'''

        table = (
            '\n'
            'cases            : {0:d}\n'
            'succeeded        : {1:d}\n'
            'failed           : {2:d}\n'
            ).format(
            plan.num_cases(),
            len(plan.succeeded_cases()),
            len(plan.failed_cases()))

        n = len(plan.skipped_cases())
        if n > 0:
            table += (
                'skipped          : {0:d}\n'
                .format(n))

        table += (
            'time taken [sec] : {0:.0f}\n'
            .format(plan.total_elapsed_time()))

        if world['randomize']:
            table += (
                'random seed      : {0:d}\n'
                .format(world['random seed']))

        self.printer.write(table)

        if plan.has_succeeded():
            self.printer.write('\nSUCCESS\n', 'green')
        else:
            self.printer.write('\nFAILURE\n', 'red')

            # list of failed test cases
            lines = [
                '- {0:s}\n'.format(case.description)
                for case in plan.failed_cases()]
            self.printer.write('\n' + ''.join(lines))


class TAPFormat(Format):
    '''TAP format'''

    def __init__(self, printer):
        self.printer = printer
        self.test_counter = 0

    def print_header(self, plan):
        '''TAP format has no header'''
        pass

    def print_case_result(self, case_result):
        '''Print TAP test case result'''

        self.test_counter += 1

        if case_result.status == CaseResult.SUCCEEDED:
            s = 'ok {0:d} {1:s}\n'.format(
                self.test_counter,
                case_result.description)
        elif case_result.status == CaseResult.FAILED:
            s = 'not ok {0:d} {1:s}\n'.format(
                self.test_counter,
                case_result.description)
        elif case_result.status == CaseResult.SKIPPED:
            s = 'ok {0:d} # SKIP {1:s}\n'.format(
                self.test_counter,
                case_result.description)
        else:
            assert False

        self.printer.write(s)

        if case_result.message != '':
            # put '# ' at the front of each line
            message = '\n'.join(
                ['# ' + line for line
                    in case_result.message.splitlines()]) + '\n'
            self.printer.write(message)

    def print_message_line(self, line):
        '''Print message with a prefix of "# "'''
        self.printer.write('# ' + line + '\n')

    def print_footer(self, plan):
        '''Print TAP plan "1..N" at the last'''
        self.printer.write(
            '1..{0:d}\n'
            .format(self.test_counter))


class MultiFormat(Format):
    '''Write messages with multiple formats'''

    def __init__(self, format_list):
        self.format_list = format_list

    def print_header(self, plan):
        for f in self.format_list:
            f.print_header(plan)

    def print_case_result(self, case_result):
        for f in self.format_list:
            f.print_case_result(case_result)

    def print_message_line(self, line):
        for f in self.format_list:
            f.print_message_line(line)

    def print_footer(self, plan):
        for f in self.format_list:
            f.print_footer(plan)


class Plan(list):
    '''List of operation objects'''

    def run(self, out_format):
        '''Run the operations and print the result with the output format'''

        out_format.print_header(self)

        # For each operations
        for op in self:
            op.run(out_format)

            if world['stop on failure'] and op.has_failed():
                world['skip all'] = True

        out_format.print_footer(self)

    def num_operations(self):
        '''Return the number of operation'''
        return len(self)

    def num_cases(self):
        '''Return the number of test cases'''
        return sum(map(
            lambda op: len(op.case_results),
            self))

    def succeeded_oparations(self):
        '''Return all succeeded operations'''
        return list(filter(
            lambda o: o.has_succeeded(),
            self))

    def failed_oparations(self):
        '''Return all failed operations'''
        return list(filter(
            lambda o: o.has_failed(),
            self))

    def skipped_operations(self):
        '''Return all skipped operations'''
        return list(filter(
            lambda o: not o.has_succeeded() and not o.has_failed(),
            self))

    def __filter_cases(self, status):
        cc = []
        for op in self:
            for c in op.case_results:
                if c.status == status:
                    cc.append(c)
        return cc

    def succeeded_cases(self):
        '''Return all succeeded test cases'''
        return self.__filter_cases(CaseResult.SUCCEEDED)

    def failed_cases(self):
        '''Return all failed test cases'''
        return self.__filter_cases(CaseResult.FAILED)

    def skipped_cases(self):
        '''Return all skipped test cases'''
        return self.__filter_cases(CaseResult.SKIPPED)

    def total_elapsed_time(self):
        '''Return the total taken time'''
        return sum([o.elapsed for o in self])

    def has_succeeded(self):
        '''Return True if no operation failed'''
        return not len(self.failed_oparations()) > 0


class MyError(Exception):
    '''Error to be handled'''
    pass


def main():
    '''Main function'''

    global world
    world = Environment()
    world.setup()
    tree = Tree(world['root dir'])
    plan = Planner().create_plan(tree)

    result_file = os.path.join(world['output dir'], 'result.txt')
    with codecs.open(
            result_file, mode='w', encoding='utf8') as f:
        file_format = TAPFormat(Printer(f))

        console = Printer(sys.stdout)
        if world['format'] == 'pretty':
            console_format = PrettyFormat(console)
        elif world['format'] == 'TAP':
            console_format = TAPFormat(console)

        multi_format = MultiFormat([file_format, console_format])
        plan.run(multi_format)

    if plan.has_succeeded():
        return 0
    else:
        return 1

if __name__ == '__main__':
    try:
        status = main()
        sys.exit(status)
    except MyError as e:
        sys.stderr.write('ttap: ' + str(e) + '\n')
        sys.exit(2)
