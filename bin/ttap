#!/usr/bin/env python2
# coding: utf-8

'''
ttap: a testing framework with file system hierarchy
'''

from abc import ABCMeta, abstractmethod
from argparse import ArgumentParser
from copy import copy
import os
import random
import re
import shutil
from signal import SIGINT
from subprocess import Popen, PIPE, STDOUT
import sys
from time import time

# global configuration object
world = None

# default configuration values
default = {
    'output dir': '/tmp/ttap',
    'test regex': '^test',
    'run regex': '^run',
    'before regex': '^before',
    'after regex': '^after',
    'init regex': '^init',
    'final regex': '^final',
    'tap regex': r'^.+\.(bats|t)$',
    }


class MyParser(ArgumentParser):
    '''
    My argument parser
    '''

    def __new__(cls):
        '''
        Create my parser. Define options and usage document.
        '''
        parser = ArgumentParser(
            description='a testing framework with file system hierarchy')

        parser.add_argument(
            'PATH',
            nargs=1,
            help="path to a test suite's root directory")
        d = default['output dir']
        parser.add_argument(
            '-o', '--output',
            metavar='PATH',
            nargs=1,
            # do not set default value because we change behavior
            # if this option is set or not in Environment()
            default=[d],
            help=('path to a directory saving the result. '
                  'default: {0}').format(d))

        parser.add_argument(
            '--tap',
            action='store_true',
            default=False,
            help='show result with TAP format')

        parser.add_argument(
            '--no-color',
            action='store_true',
            help='do not color output')

        parser.add_argument(
            '--no-change-dir',
            action='store_true',
            help='do not change the working directory')

        quality_group = parser.add_argument_group(
            'options for improvement of test suites')
        quality_group.add_argument(
            '--randomize',
            metavar='SEED',
            nargs='?',
            type=int,
            default=None,  # it means this options is not set
            const=random.randint(0, 65535),
            help='randomize the order of running tests')
        quality_group.add_argument(
            '--multiply-preconditioning',
            action='store_true',
            help='run preconditioning scripts twice in a row')

        debug_group = parser.add_argument_group(
            'options for testing of test suites')
        debug_group.add_argument(
            '--print-log',
            action='store_true',
            help='print stdout and stderr of running scripts')
        debug_group.add_argument(
            '--stop-on-failure',
            action='store_true',
            help='skip remaining operations if an operation fails')

        skip_group = debug_group.add_mutually_exclusive_group()
        skip_group.add_argument(
            '--skip-all',
            action='store_true',
            help='skip all operations')
        skip_group.add_argument(
            '--only',
            metavar='NAME',
            nargs='+',
            type=str,
            default=[],
            help='run only specified scripts')
        skip_group.add_argument(
            '--skip',
            metavar='NAME',
            nargs='+',
            type=str,
            default=[],
            help='skip specified scripts')

        prefix_group = parser.add_argument_group(
            'regular expressions for classifying node types')
        d = default['test regex']
        prefix_group.add_argument(
            '--test-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with test-nodes. '
                  'default: {0}').format(d))
        d = default['run regex']
        prefix_group.add_argument(
            '--run-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with run-nodes. '
                  'default: {0}').format(d))
        d = default['before regex']
        prefix_group.add_argument(
            '--before-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with before-nodes. '
                  'default: {0}').format(d))
        d = default['after regex']
        prefix_group.add_argument(
            '--after-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with after-nodes. '
                  'default: {0}').format(d))
        d = default['init regex']
        prefix_group.add_argument(
            '--init-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with init-nodes. '
                  'default: {0}').format(d))
        d = default['final regex']
        prefix_group.add_argument(
            '--final-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with final-nodes. '
                  'default: {0}').format(d))

        protocol_group = parser.add_argument_group(
            'regular expressions for classifying output protocols')
        d = default['tap regex']
        protocol_group.add_argument(
            '--tap-regex',
            metavar='RE',
            nargs=1,
            default=[d],
            help=('regex matching with script files which output '
                  'are formatted with Test Anything Protocol. '
                  'default: {0}').format(d))

        return parser


class Environment(dict):
    '''
    Dictionally of configuration properties
    '''

    def __init__(self):
        args = MyParser().parse_args()

        self['root dir'] = os.path.abspath(args.PATH[0])
        self['output dir'] = os.path.abspath(args.output[0])

        if args.tap is True:
            self['format'] = 'TAP'
        else:
            self['format'] = 'pretty'

        self['color output'] = not args.no_color
        self['change dir'] = not args.no_change_dir

        ## Quality options

        # when --randomize option is assigned
        if args.randomize:
            self['randomize'] = True
            self['random seed'] = args.randomize
            random.seed(args.randomize)
        else:
            self['randomize'] = False

        self['multiply preconditioning'] = args.multiply_preconditioning

        ## Testing for test options

        self['print log'] = args.print_log
        self['stop on failure'] = args.stop_on_failure

        # note: can be changed in running
        self['skip all'] = args.skip_all

        # absolute paths of only-run files or directory
        self['only list'] = [os.path.join(self['root dir'], n)
                             for n in args.only]
        # absolute paths of skipped files
        self['skip list'] = [os.path.join(self['root dir'], n)
                             for n in args.skip]

        for p in self['skip list'] + self['only list']:
            if not os.path.exists(p):
                raise MyError("No such file or directory: '{0}'"
                              .format(os.path.relpath(p)))

        ## Regex options

        self['test regex'] = re.compile(args.test_regex[0])
        self['run regex'] = re.compile(args.run_regex[0])
        self['before regex'] = re.compile(args.before_regex[0])
        self['after regex'] = re.compile(args.after_regex[0])
        self['init regex'] = re.compile(args.init_regex[0])
        self['final regex'] = re.compile(args.final_regex[0])

        self['tap regex'] = re.compile(args.tap_regex[0])

    def setup(self):
        '''
        Set up environment.
        '''
        # for repeatable running, cleanup the output directory
        # if -o option is not assigned
        d = default['output dir']
        if self['output dir'] == d:
            if os.path.lexists(d):
                try:
                    shutil.rmtree(d)
                except OSError as e:
                    raise MyError(e)

        # create the output directory
        try:
            os.makedirs(self['output dir'])
        except OSError as e:
            raise MyError(e)

        # set environment variables in the process
        os.environ['TTAP_EXEC_DIR'] = os.getcwd()
        os.environ['TTAP_ROOT_DIR'] = self['root dir']
        os.environ['TTAP_OUTPUT_DIR'] = self['output dir']


class Path():
    '''
    Path string
    '''
    def __init__(self, path_string):
        self.path_string = os.path.abspath(path_string)

    def __cmp__(self, other):
        return cmp(self.path_string, other.path_string)

    def __str__(self):
        return os.path.relpath(self.path_string, world["root dir"])

    def abspath(self):
        '''
        Return the absolute path string
        '''
        return self.path_string

    def normalized(self):
        '''
        Return the relative path from the root
        directory of the test suite
        '''
        return str(self)

    def basename(self):
        '''
        Return the file name
        '''
        return os.path.basename(self.path_string)

    def dirname(self):
        '''
        Return the directory name where the file exists
        '''
        return os.path.dirname(self.path_string)

    def is_executable(self):
        '''
        Return True if the file is executable
        '''
        return os.access(self.path_string, os.R_OK | os.X_OK)

    def startswith(self, path_string):
        '''
        Return True if the path starts with the given path string
        '''
        assert os.path.isabs(path_string)
        return self.path_string.startswith(path_string)


class Node():
    '''
    A node of the scripts tree, a directory.
    '''

    def __init__(
            self, path,
            tests, runs,
            befores, afters,
            inits, finals):

        self.path = path

        # child nodes
        self.tests = tests
        self.runs = runs
        self.befores = befores
        self.afters = afters
        self.inits = inits
        self.finals = finals

    def __str__(self):
        return str(self.path)

    def name(self):
        '''
        Get the directory or file name, not the path.
        '''
        return self.path.basename()

    def is_empty(self):
        '''
        Return True if this node does not have child nodes
        '''
        if (self.tests and self.runs and
                self.befores and self.afters and
                self.inits and self.finals):
            return True
        else:
            return False

    def accept(self, visitor):
        visitor.visit_node(self)


class Leaf():
    '''
    A script file
    '''

    def __init__(self, path):
        self.path = path

    def __str__(self):
        return str(self.path)

    def name(self):
        return self.path.basename()

    def is_empty(self):
        return False

    def accept(self, visitor):
        visitor.visit_leaf(self)


class NodeGroup(list):
    '''
    List of node objects
    '''
    __metaclass__ = ABCMeta

    def randomized(self):
        '''
        Return randomized node list
        '''
        out = self.sorted()
        if world['randomize']:
            random.shuffle(out)
        return out

    def sorted(self, reverse=False):
        '''
        Return node list sorted by path name
        '''
        return sorted(self, key=lambda node: node.path, reverse=reverse)

    @abstractmethod
    def accept(self, visitor):
        pass


class TestGroup(NodeGroup):
    '''
    List of test-nodes
    '''
    def accept(self, visitor):
        visitor.visit_test_group(self)


class RunGroup(NodeGroup):
    '''
    List of run-nodes
    '''
    def accept(self, visitor):
        visitor.visit_run_group(self)


class BeforeGroup(NodeGroup):
    '''
    List of before-nodes
    '''
    def accept(self, visitor):
        visitor.visit_before_group(self)


class AfterGroup(NodeGroup):
    '''
    List of after-nodes
    '''
    def accept(self, visitor):
        visitor.visit_after_group(self)


class InitGroup(NodeGroup):
    '''
    List of init-nodes
    '''
    def accept(self, visitor):
        visitor.visit_init_group(self)


class FinalGroup(NodeGroup):
    '''
    List of final-nodes
    '''
    def accept(self, visitor):
        visitor.visit_final_group(self)


class Tree():
    '''
    A tree of node objects

    It traces the directory structure of the test suites.
    '''

    def __init__(self, root_path):
        '''
        Create tree
        '''
        try:
            self.root_node = self.__create_nodes(root_path)
        except OSError as e:
            raise MyError(e)

    class StringFormatter():
        '''
        Format string from Tree object
        '''

        def get_string(self, tree):
            '''
            Return string object
            '''
            self.string = ''
            self.indent = ''
            tree.root_node.accept(self)
            return self.string

        def visit_node(self, node):
            self.string += self.indent + '- ' + node.name() + '\n'

            indent_copy = copy(self.indent)
            self.indent += '  '

            node.inits.accept(self)
            node.befores.accept(self)
            node.runs.accept(self)
            node.tests.accept(self)
            node.afters.accept(self)
            node.finals.accept(self)

            self.indent = indent_copy

        def visit_leaf(self, leaf):
            self.string += self.indent + '- ' + leaf.name() + '\n'

        def visit_test_group(self, test_group):
            for test in test_group.sorted():
                test.accept(self)

        def visit_run_group(self, run_group):
            for run in run_group.sorted():
                run.accept(self)

        def visit_before_group(self, before_group):
            for before in before_group.sorted():
                before.accept(self)

        def visit_after_group(self, after_group):
            for after in after_group.sorted(reverse=True):
                after.accept(self)

        def visit_init_group(self, init_group):
            for init in init_group.sorted():
                init.accept(self)

        def visit_final_group(self, final_group):
            for final in final_group.sorted(reverse=True):
                final.accept(self)

    def __str__(self):
        return Tree.StringFormatter().get_string(self)

    def __create_nodes(self, path):
        '''
        Create node objects under the path recursively
        and return a node object that represents the path
        '''

        if os.path.isfile(path):
            return Leaf(Path(path))

        def __create_child_nodes(childs, regex):
            names = filter(lambda n: regex.match(n), childs)
            pathes = map(lambda n: os.path.join(path, n), names)
            nodes = map(lambda p: self.__create_nodes(p), pathes)
            non_empty_nodes = filter(lambda n: not n.is_empty(), nodes)
            return non_empty_nodes

        childs = os.listdir(path)

        tests = TestGroup()
        nodes = __create_child_nodes(childs, world['test regex'])
        tests.extend(nodes)

        runs = RunGroup()
        nodes = __create_child_nodes(childs, world['run regex'])
        runs.extend(nodes)

        befores = BeforeGroup()
        nodes = __create_child_nodes(childs, world['before regex'])
        befores.extend(nodes)

        afters = AfterGroup()
        nodes = __create_child_nodes(childs, world['after regex'])
        afters.extend(nodes)

        inits = InitGroup()
        nodes = __create_child_nodes(childs, world['init regex'])
        inits.extend(nodes)

        finals = FinalGroup()
        nodes = __create_child_nodes(childs, world['final regex'])
        finals.extend(nodes)

        return Node(Path(path), tests, runs,
                    befores, afters, inits, finals)


class Printer():
    '''
    write strings to a file
    '''
    __color_head = {
        'red': '\033[91m',
        'green': '\033[92m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
    }

    def __init__(self, out):
        '''
        Initialize printer with a file object
        '''
        self.out = out

    def write(self, message, color=None):
        '''
        Write the message with a color
        '''
        if world['color output'] and color:
            end = '\033[0m'
            message = Printer.__color_head[color] + message + end
        self.out.write(message)
        self.out.flush()


class NullFile():
    '''
    Null file object
    '''

    def write(self, string):
        pass

    def flush(self):
        pass


class CaseResult():
    '''
    Result of test case
    '''
    (
        SUCCEEDED,
        FAILED,
        SKIPPED,
    ) = range(3)

    def __init__(self, status, description, message):
        assert (status == self.SUCCEEDED or
                status == self.FAILED or
                status == self.SKIPPED)

        self.status = status
        self.description = description
        self.message = message


class Protocol():
    '''
    Protocol of scripts
    '''
    __metaclass__ = ABCMeta

    def set_format(self, out_format):
        self.out_format = out_format

    def set_operation_name(self, name):
        self.opname = name

    @abstractmethod
    def decode_stdout(self, iterable_lines):
        pass

    @abstractmethod
    def decode_statuscode(self, statuscode):
        pass

    @abstractmethod
    def get_results(self):
        pass


class StandardProtocol(Protocol):
    '''
    Simple protocol

    Operations succeed when scripts exit with a zero status.
    Operations fail when scripts exit with a non-zero status.
    '''

    def decode_stdout(self, iterable_lines):
        '''
        Print stdout to console when --print-log option is set
        '''

        if world['print log']:
            console = Printer(sys.stderr)
        else:
            console = Printer(NullFile())

        console.write(
            '\n➤ {0:s}\n'.format(self.opname),
            'blue')

        for line in iterable_lines:
            console.write(line)

    def decode_statuscode(self, statuscode):
        '''
        The operation fails if it returns non-zero status code
        '''
        if statuscode == 0:
            status = CaseResult.SUCCEEDED
        else:
            status = CaseResult.FAILED

        result = CaseResult(status, self.opname, '')
        self.out_format.print_case_result(result)
        self.results = [result]

    def get_results(self):
        return self.results


class TestAnythingProtocol(Protocol):
    '''
    Test Anything Protocol (TAP)
    '''

    RE_PLAN = re.compile(r'^1\.\.(\d+)(.*)$')
    RE_OK = re.compile(r'^ok\s+(\d+)(\s+-)?\s+(.*)$')
    RE_NOT_OK = re.compile(r'^not\sok\s+(\d+)(\s+-)?\s+(.*)$')
    RE_SKIP = re.compile(r'^ok\s+(\d+)(\s+-)?\s+(# (SKIP|skip|Skip))\s+(.*)$')
    RE_COMMENT = re.compile(r'^#\s(.*)$')
    RE_BAILOUT = re.compile(r'^Bail out!(.*)$')

    def __init__(self):
        self.results = []
        self.failed = False
        self.bailouted = False

    def decode_stdout(self, iterable_lines):
        '''
        Decode TAP-formatted result
        '''

        # TODO: validate protocol

        for line in iterable_lines:
            if self.RE_PLAN.match(line):
                continue

            if self.RE_SKIP.match(line):
                result = CaseResult(
                    CaseResult.SKIPPED,
                    self.opname + ': ' + self.RE_SKIP.match(line).group(5),
                    '')

                self.out_format.print_case_result(result)
                self.results.append(result)
                self.failed = True
                continue

            if self.RE_OK.match(line):
                result = CaseResult(
                    CaseResult.SUCCEEDED,
                    self.opname + ': ' + self.RE_OK.match(line).group(3),
                    '')

                self.out_format.print_case_result(result)
                self.results.append(result)
                continue

            if self.RE_NOT_OK.match(line):
                result = CaseResult(
                    CaseResult.FAILED,
                    self.opname + ': ' + self.RE_NOT_OK.match(line).group(3),
                    '')

                self.out_format.print_case_result(result)
                self.results.append(result)
                self.failed = True
                continue

            if self.RE_COMMENT.match(line):
                self.out_format.print_message_line(
                    self.RE_COMMENT.match(line).group(1))
                continue

            if self.RE_BAILOUT.match(line):
                result = CaseResult(
                    CaseResult.FAILED,
                    self.opname,
                    line)

                self.out_format.print_case_result(result)
                self.results.append(result)
                self.bailouted = True
                return

    def decode_statuscode(self, statuscode):
        '''
        Print failure only if the script exits with
        a non-zero status code but all tests succeed.
        '''
        if self.bailouted:
            return
        if self.failed:
            return
        if statuscode == 0:
            return

        result = CaseResult(
            CaseResult.FAILED,
            self.opname,
            '')
        self.out_format.print_case_result(result)
        self.results.append(result)

    def get_results(self):
        return self.results


class Operation():
    '''
    A unit of testing. Represent each executable script file.
    '''

    def __init__(self, path, depends, protocol):
        self.path = path
        self.depends = copy(depends)

        self.has_done = False
        self.elapsed = 0.0
        self.case_results = None

        # unique number among all operations
        self.id_num = 0

        # unique number among operations with the same file
        # 1 or more value is set if a file associated to
        # two or more operations.
        self.serial_num = 0

        self.protocol = protocol

    def set_id(self, id_num):
        assert self.id_num == 0
        assert id_num > 0
        self.id_num = id_num

    def set_serial(self, serial_num):
        assert self.serial_num == 0
        assert serial_num > 0
        self.serial_num = serial_num

    def __str__(self):
        if self.serial_num > 0:
            return '{0:s}.{1:d}'.format(
                self.path, self.serial_num)
        else:
            return str(self.path)

    def logfile_name(self):
        '''
        Get the log file name about this object
        '''
        return '{0:s}.out'.format(
            str(self).replace(os.sep, '.'))

    def has_succeeded(self):
        '''
        Return True if all test cases have succeeded
        '''
        for result in self.case_results:
            if result.status != CaseResult.SUCCEEDED:
                return False

        return True

    def has_failed(self):
        '''
        Return True if one or more test cases have failed
        (not succeeded and notskipped)
        '''
        for result in self.case_results:
            if result.status == CaseResult.FAILED:
                return True

        return False

    def run(self, out_format):
        '''
        Exec this operation.
        The result is printed to out_format and set into field variables.
        '''
        assert self.id_num > 0
        assert not self.has_done
        assert self.case_results is None

        def abort(status, message):
            result = CaseResult(status, str(self), message)

            out_format.print_case_result(result)

            self.case_results = [result]
            self.has_done = True

        if world['skip all']:
            abort(CaseResult.SKIPPED, '')
            return

        # skip if the path of the operation is
        # under the directory in skip list
        for skip_file in world['skip list']:
            if self.path.startswith(skip_file):
                abort(CaseResult.SKIPPED, '')
                return

        # skip if the path of the operation is
        # under the directory in only list
        if len(world['only list']) > 0:
            for only_file in world['only list']:
                if self.path.startswith(only_file):
                    break
            else:
                abort(CaseResult.SKIPPED, '')
                return

        # Skip if depending operation did not succeed.
        for depend_op in self.depends:

            assert depend_op.has_done

            if not depend_op.has_succeeded():
                message = (
                    'depending operation did not succeed: {0:s}'
                    .format(depend_op))
                abort(CaseResult.SKIPPED, message)
                return

        # Failed if the file is not executable.
        if not self.path.is_executable():
            message = '{0:s} is not executable.'.format(self.path)
            abort(CaseResult.FAILED, message)
            return

        if world['change dir']:
            # Change the working directory to the directory where
            # the script exists.
            os.chdir(self.path.dirname())

        start = time()

        #results = self.executor.run(self, out_format)
        self.protocol.set_format(out_format)
        self.protocol.set_operation_name(str(self))

        try:
            process = Popen(
                [self.path.abspath()],
                stdout=PIPE,
                stderr=STDOUT)

            logfile = os.path.join(
                world['output dir'], self.logfile_name())

            # write stdout and stderr of the operation
            # to stderr and logfile
            with process.stdout, open(logfile, 'wb') as f:

                def readline():
                    line = process.stdout.readline()
                    # write stdout to log file when read
                    f.write(line)
                    return line

                iterator = iter(readline, b'')

                self.protocol.decode_stdout(iterator)

            process.wait()

        except OSError as e:
            # For the case when the script at the path has not shebang.
            message = (
                'OSError: ' + str(e) + '\n'
                'Is the shebang correct?')
            abort(CaseResult.FAILED, message)
            return

        except KeyboardInterrupt as i:
            process.send_signal(SIGINT)
            process.wait()
            message = 'KeyboardInterrupt'
            abort(CaseResult.FAILED, message)
            return

        self.protocol.decode_statuscode(process.returncode)
        self.case_results = self.protocol.get_results()

        end = time()
        self.elapsed = end - start
        self.has_done = True


class Planner():
    '''
    Create an operation plan
    '''

    # use the visitor design patten.
    # this visits Node class and NodeGroup class recursively.

    def create_plan(self, tree):
        '''
        Return a plan object
        '''
        self.planned_operations = Plan()
        self.depended_operations = []
        tree.root_node.accept(self)
        assert len(self.depended_operations) == 0

        # set id numbers
        id_num = 0
        for op in self.planned_operations:
            id_num += 1
            op.set_id(id_num)

        # set serial numbers
        for op in self.planned_operations:
            c = filter(
                lambda o: o.path == op.path, self.planned_operations)
            assert len(c) > 0
            if len(c) == 1:
                continue
            n = max(map(lambda o: o.serial_num, c))
            op.set_serial(n + 1)

        return self.planned_operations

    def visit_node(self, node):
        '''
        Define the relations between node types
        '''

        # accept method must be sandwiched between __set and __reset.
        __m = []

        def __set(list):
            '''Remember the current state '''
            __m.append(len(list))

        def __reset(list):
            ''' Reset to the remembered state '''
            length = __m.pop()
            del list[length:]

        __set(self.depended_operations)

        node.inits.accept(self)
        if world['multiply preconditioning']:
            node.inits.accept(self)

        # note: temporary execute before-operations and after-operations
        # respectively before and after run-operations. In the future, we
        # might prohibit that a node contains both of run-operations and
        # other operations.

        if len(node.runs) > 0:
            __set(self.depended_operations)

            node.befores.accept(self)
            node.runs.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        first_test = True
        for test in node.tests.randomized():
            __set(self.depended_operations)

            node.befores.accept(self)
            if world['multiply preconditioning'] and first_test:
                node.befores.accept(self)
            first_test = False

            test.accept(self)

            __reset(self.depended_operations)
            __set(self.depended_operations)

            node.afters.accept(self)

            __reset(self.depended_operations)

        __reset(self.depended_operations)
        __set(self.depended_operations)

        node.finals.accept(self)

        __reset(self.depended_operations)

    def visit_leaf(self, leaf):
        '''
        Add new operation object
        '''

        if world['tap regex'].match(leaf.path.basename()):
            protocol = TestAnythingProtocol()
        else:
            protocol = StandardProtocol()

        operation = Operation(
            leaf.path,
            self.depended_operations,
            protocol)
        self.planned_operations.append(operation)
        self.depended_operations.append(operation)

    def visit_test_group(self, test_group):
        '''
        This planner do not do not visit test-group
        '''
        assert False

    def visit_run_group(self, run_group):
        '''
        Visit run-nodes in the sequential order
        '''
        for run_node in run_group.sorted():
            run_node.accept(self)

    def visit_before_group(self, before_group):
        '''
        Visit before-nodes in the sequential order
        '''
        for before_node in before_group.sorted():
            before_node.accept(self)

    def visit_after_group(self, after_group):
        '''
        Visit after-nodes in the reversed order
        '''
        for after_node in after_group.sorted(reverse=True):
            after_node.accept(self)

    def visit_init_group(self, init_group):
        '''
        Visit init-nodes in the sequential order
        '''
        for init_node in init_group.sorted():
            init_node.accept(self)

    def visit_final_group(self, final_group):
        '''
        Visit final-nodes in the sequential order
        '''
        for final_node in final_group.sorted(reverse=True):
            final_node.accept(self)


class Format:
    '''
    Output format of test result
    '''
    __metaclass__ = ABCMeta

    @abstractmethod
    def print_header(self, plan):
        pass

    @abstractmethod
    def print_case_result(self, case_result):
        pass

    @abstractmethod
    def print_message_line(self, line):
        pass

    @abstractmethod
    def print_footer(self, plan):
        pass


class PrettyFormat(Format):
    '''
    Pretty format
    '''

    def __init__(self, printer):
        self.printer = printer

    def print_header(self, plan):
        '''
        No header
        '''
        pass

    def print_case_result(self, case_result):
        '''
        Print pretty test case result
        '''

        if case_result.status == CaseResult.SUCCEEDED:
            s = '✓ {0:s}\n'.format(case_result.description)
            self.printer.write(s, 'green')
        elif case_result.status == CaseResult.FAILED:
            s = '✗ {0:s}\n'.format(case_result.description)
            self.printer.write(s, 'red')
        elif case_result.status == CaseResult.SKIPPED:
            s = '− {0:s}\n'.format(case_result.description)
            self.printer.write(s, 'yellow')
        else:
            assert False

        if case_result.message != '':
            message = (
                '\n'.join(
                    ['  ' + line for line in case_result.message.splitlines()])
                + '\n'
                )
            self.printer.write(message)

    def print_message_line(self, line):
        self.printer.write('  ' + line + '\n')

    def print_footer(self, plan):
        '''
        Print summury
        '''

        table = (
            '\n'
            'cases            : {0:d}\n'
            'succeeded        : {1:d}\n'
            'failed           : {2:d}\n'
            ).format(
            plan.num_cases(),
            len(plan.succeeded_cases()),
            len(plan.failed_cases()))

        n = len(plan.skipped_cases())
        if n > 0:
            table += (
                'skipped          : {0:d}\n'
                .format(n))

        table += (
            'time taken [sec] : {0:.0f}\n'
            .format(plan.total_elapsed_time()))

        if world['randomize']:
            table += (
                'random seed      : {0:d}\n'
                .format(world['random seed']))

        self.printer.write(table)

        if plan.has_succeeded():
            self.printer.write('\nSUCCESS\n', 'green')
        else:
            self.printer.write('\nFAILURE\n', 'red')

            # list of failed oparations
            lines = [
                '- {0:s}\n'.format(o)
                for o in plan.failed_oparations()]
            self.printer.write('\n' + ''.join(lines))


class TAPFormat(Format):
    '''
    TAP format
    '''

    def __init__(self, printer):
        self.printer = printer
        self.test_counter = 0

    def print_header(self, plan):
        pass

    def print_case_result(self, case_result):
        '''
        Print TAP test case result
        '''

        self.test_counter += 1

        if case_result.status == CaseResult.SUCCEEDED:
            s = 'ok {0:d} {1:s}\n'.format(
                self.test_counter,
                case_result.description)
        elif case_result.status == CaseResult.FAILED:
            s = 'not ok {0:d} {1:s}\n'.format(
                self.test_counter,
                case_result.description)
        elif case_result.status == CaseResult.SKIPPED:
            s = 'ok {0:d} # SKIP {1:s}\n'.format(
                self.test_counter,
                case_result.description)
        else:
            assert False

        self.printer.write(s)

        if case_result.message != '':
            # put '# ' at the front of each line
            message = (
                '\n'.join(
                    ['# ' + line for line in case_result.message.splitlines()])
                + '\n'
                )
            self.printer.write(message)

    def print_message_line(self, line):
        self.printer.write('# ' + line + '\n')

    def print_footer(self, plan):
        '''
        Print TAP plan (1..N) at last
        '''
        self.printer.write(
            '1..{0:d}\n'
            .format(self.test_counter))


class MultiFormat(Format):
    '''
    Write with multiple format
    '''

    def __init__(self, format_list):
        self.format_list = format_list

    def print_header(self, plan):
        for f in self.format_list:
            f.print_header(plan)

    def print_case_result(self, case_result):
        for f in self.format_list:
            f.print_case_result(case_result)

    def print_message_line(self, line):
        for f in self.format_list:
            f.print_message_line(line)

    def print_footer(self, plan):
        for f in self.format_list:
            f.print_footer(plan)


class Plan(list):
    '''
    List of operation objects.
    '''

    def run(self, out_format):
        '''
        Run the operations and print the result with out_format
        '''

        out_format.print_header(self)

        # For each operations
        for op in self:
            op.run(out_format)

            if (world['stop on failure'] and op.has_failed()):
                world['skip all'] = True

        out_format.print_footer(self)

    def num_operations(self):
        '''
        Return the number of operation
        '''
        return len(self)

    def num_cases(self):
        '''
        Return the number of test cases
        '''
        return sum(map(
            lambda op: len(op.case_results),
            self))

    def succeeded_oparations(self):
        '''
        Return all succeeded operations
        '''
        return filter(
            lambda o: o.has_succeeded(),
            self)

    def failed_oparations(self):
        '''
        Return all failed operations
        '''
        return filter(
            lambda o: o.has_failed(),
            self)

    def skipped_operations(self):
        '''
        Return all skipped operations
        '''
        return filter(
            lambda o: not o.has_succeeded() and not o.has_failed(),
            self)

    def __filter_cases(self, status):
        cc = []
        for op in self:
            for c in op.case_results:
                if c.status == status:
                    cc.append(c)
        return cc

    def succeeded_cases(self):
        '''
        Return all succeeded test cases
        '''
        return self.__filter_cases(CaseResult.SUCCEEDED)

    def failed_cases(self):
        '''
        Return all failed test cases
        '''
        return self.__filter_cases(CaseResult.FAILED)

    def skipped_cases(self):
        '''
        Return all skipped test cases
        '''
        return self.__filter_cases(CaseResult.SKIPPED)

    def total_elapsed_time(self):
        '''
        Return total taken time
        '''
        return sum([o.elapsed for o in self])

    def has_succeeded(self):
        '''
        Return True if no operation failed
        '''
        return not len(self.failed_oparations()) > 0


class MyError(Exception):
    '''
    Error to be handled
    '''
    pass


def main():
    global world
    world = Environment()
    world.setup()
    tree = Tree(world['root dir'])
    plan = Planner().create_plan(tree)

    result_file = os.path.join(world['output dir'], 'result.txt')
    with open(result_file, 'w') as f:
        file_format = TAPFormat(Printer(f))

        console = Printer(sys.stdout)
        if world['format'] == 'pretty':
            console_format = PrettyFormat(console)
        elif world['format'] == 'TAP':
            console_format = TAPFormat(console)

        multi_format = MultiFormat([file_format, console_format])
        plan.run(multi_format)

    if plan.has_succeeded():
        return 0
    else:
        return 1

if __name__ == '__main__':
    try:
        status = main()
        sys.exit(status)
    except MyError as e:
        print >> sys.stderr, 'ttap:', e
        sys.exit(2)
